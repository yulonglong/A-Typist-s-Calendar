//@author: a0103494j



	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\Deadline.java
	 */

package com.licensetokil.atypistcalendar.tasksmanager;

import java.text.SimpleDateFormat;
import java.util.Calendar;

public class Deadline extends Task implements Comparable<Deadline>, Cloneable {
	private static final String OUTPUT_FORMAT = "[%s] [by %s] [Status: %s] %s";
	private String remoteId;
	private TaskType taskType;
	private int uniqueId;
	private Calendar lastModifiedDate;
	private Calendar endTime;
	private String description;
	private String place;
	private String status;

	public Deadline(int uniqueId, Calendar endTime, String description,
			String place, String status, Calendar lastModifiedDate) {
		this.taskType = TaskType.DEADLINE;
		this.endTime = endTime;
		this.description = description;
		this.place = place;
		this.uniqueId = uniqueId;
		this.status = status;
		this.lastModifiedDate = lastModifiedDate;
	}

	public Deadline() {
	}

	public String getRemoteId() {
		return remoteId;
	}

	public int getUniqueId() {
		return uniqueId;
	}

	public TaskType getTaskType() {
		return taskType;
	}

	public Calendar getLastModifiedDate() {
		return lastModifiedDate;
	}

	public Calendar getEndTime() {
		return endTime;
	}

	public String getDescription() {
		return description;
	}

	public String getPlace() {
		return place;
	}

	public String getStatus() {
		return status;
	}

	public void setEndTime(Calendar st) {
		this.endTime = st;
	}

	public void setDescription(String d) {
		this.description = d;
	}

	public void setPlace(String p) {
		this.place = p;
	}

	public void setStatus(String s) {
		this.status = s;
	}

	public void setRemoteId(String remoteId) {
		this.remoteId = remoteId;
	}

	public void setTaskType(TaskType t) {
		this.taskType = t;
	}

	public void setUniqueId(int uniqueId) {
		this.uniqueId = uniqueId;
	}

	public void setLastModifiedDate(Calendar lastModifiedDate) {
		this.lastModifiedDate = lastModifiedDate;
	}

	public String toString() {
		if (place.equals(EMPTY_STRING)) {
			return TaskType.DEADLINE + DELIMITER + uniqueId + DELIMITER
					+ endTime.getTime() + DELIMITER + description + DELIMITER
					+ BLANK_SPACE + DELIMITER + status + DELIMITER
					+ lastModifiedDate.getTime() + DELIMITER + remoteId;
		}
		return TaskType.DEADLINE + DELIMITER + uniqueId + DELIMITER
				+ endTime.getTime() + DELIMITER + description + DELIMITER
				+ place + DELIMITER + status + DELIMITER
				+ lastModifiedDate.getTime() + DELIMITER + remoteId;
	}

	public String outputStringForDisplay() {
		SimpleDateFormat formatTime = new SimpleDateFormat("hh:mm a");
		SimpleDateFormat formatDay = new SimpleDateFormat("EEE, MMM dd, ''yy");

		String stringStatus = status;
		if (stringStatus.equals(DONE_NO_ALIGN)) {
			stringStatus = DONE_ALIGN;
		}

		String output = String
				.format(OUTPUT_FORMAT, formatDay.format(endTime.getTime()),
						formatTime.format(endTime.getTime()), stringStatus,
						description);
		if (!place.equals(EMPTY_STRING)) {
			output = String.format(DISPLAY_PLACE_NOT_EMPTY, output,
					this.getPlace());
		}

		return output;
	}

	public int compareTo(Deadline d) {
		return endTime.compareTo(d.getEndTime());
	}

	@Override
	public Object clone() {
		Deadline clonedObject = new Deadline();
		clonedObject.remoteId = this.remoteId;
		clonedObject.taskType = this.taskType;
		clonedObject.uniqueId = this.uniqueId;
		clonedObject.description = this.description;
		clonedObject.status = this.status;
		clonedObject.place = this.place;
		clonedObject.endTime = (Calendar) this.endTime.clone();
		clonedObject.lastModifiedDate = (Calendar) this.lastModifiedDate
				.clone();

		return clonedObject;
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\Deadline.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\Deadline.java
	 */


	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\Deadline.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\JUnitTestOutput.java
	 */

package com.licensetokil.atypistcalendar.tasksmanager;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Calendar;

import org.junit.Test;

import com.licensetokil.atypistcalendar.parser.*;

public class JUnitTestOutput {

	@Test
	public void testOutput() {
		
		// ADD TESTS
		AddAction addAction = new AddAction();
		Calendar addStartTime = Calendar.getInstance();
		Calendar addEndTime = Calendar.getInstance();
		addStartTime.set(2013, 10, 25, 12, 0, 0);
		addEndTime.set(2013, 10, 25, 13, 0, 0);
		addAction.setStartTime(addStartTime);
		addAction.setEndTime(addEndTime);
		addAction.setDescription("swimming");
		addAction.setPlace("Community Centre");

		// testAdd1
		assertEquals(
				TasksManager.getInstance().executeCommand(addAction),
				"Added: \n[Mon, Nov 25, '13] [12:00 PM - 01:00 PM] swimming at Community Centre\n\n");
		
		// testAdd2
		addAction.setDescription("reply Edward");
		addAction.setStartTime(null);
		addAction.setPlace("");

		assertEquals(TasksManager.getInstance().executeCommand(addAction),
				"Added: \n[Mon, Nov 25, '13] [by 01:00 PM] [Status: undone] reply Edward\n\n");
		
		// testAdd3
		addAction.setEndTime(null);
		addAction.setDescription("clean my room");

		assertEquals(TasksManager.getInstance().executeCommand(addAction),
				"Added: \n[Status: undone] clean my room\n\n");

		System.out.println("All Add Tests pass");
		
		//ADD UNDO TEST
		addAction.setDescription("jogging tonight");
		TasksManager.getInstance().executeCommand(addAction);
		assertEquals(TasksManager.getInstance().executeCommand(new UndoAction()), "Add command successfully undone\n\n");

		
		//DISPLAY TESTS
		DisplayAction displayAction = new DisplayAction();
		Calendar dispStartTime = Calendar.getInstance();
		Calendar dispEndTime = Calendar.getInstance();
		dispStartTime.set(2000, 0, 1, 0, 0, 0);
		dispEndTime.set(2099, 11, 31, 23,59, 59);
		displayAction.setStartTime(dispStartTime);
		displayAction.setEndTime(dispEndTime);
		
		// testDisplay1
		displayAction.setDescription("schedules");
		assertEquals(
				TasksManager.getInstance().executeCommand(displayAction),
				"Schedules: \n1. [Mon, Nov 25, '13] [12:00 PM - 01:00 PM] swimming at Community Centre\n\n");

		// testDisplay2
		displayAction.setDescription("deadlines");
		assertEquals(
				TasksManager.getInstance().executeCommand(displayAction),
				"Deadlines: \n1. [Mon, Nov 25, '13] [by 01:00 PM] [Status: undone] reply Edward\n\n");

		// testDisplay3
		displayAction.setDescription("todos");
		assertEquals(TasksManager.getInstance().executeCommand(displayAction),
				"Todos: \n1. [Status: undone] clean my room\n\n");
		
		// testDisplay4
		displayAction.setDescription("all");
				assertEquals(
						TasksManager.getInstance().executeCommand(displayAction),
						"Schedules: \n1. [Mon, Nov 25, '13] [12:00 PM - 01:00 PM] swimming at Community Centre\n\nDeadlines: \n2. [Mon, Nov 25, '13] [by 01:00 PM] [Status: undone] reply Edward\n\nTodos: \n3. [Status: undone] clean my room\n\n");


		System.out.println("All Display Tests pass");
		
		//MARK TEST
		MarkAction markAction = new MarkAction();
		markAction.setStatus("done");
		ArrayList<Integer> refNum = new ArrayList<Integer>();
		refNum.add(2);
		refNum.add(3);
		markAction.setReferenceNumber(refNum);
		
		//markTest1
		assertEquals(TasksManager.getInstance().executeCommand(markAction), "Marked 2 3  as done\n\n");
		
		//markTest2
		markAction.setStatus("undone");
		assertEquals(TasksManager.getInstance().executeCommand(markAction), "Marked 2 3  as undone\n\n");
		
		//MARK UNDO TEST
		assertEquals(TasksManager.getInstance().executeCommand(new UndoAction()), "Mark command successfully undone\n\n");
		
		//Adding in todos
		addAction.setDescription("learn swimming");
		TasksManager.getInstance().executeCommand(addAction);
		addAction.setDescription("Meet Edward for catch up session");
		TasksManager.getInstance().executeCommand(addAction);
		addEndTime.set(2013, 10, 16, 23, 59, 0);
		//Adding in deadline
		addAction.setDescription("complete CS2106 project");
		TasksManager.getInstance().executeCommand(addAction);
		
		
		//SEARCH TEST
		SearchAction searchAction = new SearchAction();
		Calendar searchStartTime = Calendar.getInstance();
		Calendar searchEndTime = Calendar.getInstance();
	
		//searchTest1
		searchAction.setQuery("swimming");
		searchStartTime.set(2000, 0, 1, 0, 0, 0);
		searchEndTime.set(2099, 11, 31, 23,59, 59);
		searchAction.setStartTime(searchStartTime);
		searchAction.setEndTime(searchEndTime);
		assertEquals(TasksManager.getInstance().executeCommand(searchAction), "Search Matches: \n\nSchedules: \n1. [Mon, Nov 25, '13] [12:00 PM - 11:59 PM] swimming at Community Centre\n\nTodos: \n2. [Status: undone] learn swimming\n\n");
		
		//searchTest2
		searchStartTime.set(2013, 10, 26, 0, 0, 0);
		assertEquals(TasksManager.getInstance().executeCommand(searchAction), "Search Matches: \n\nTodos: \n1. [Status: undone] learn swimming\n\n");
		
		//searchTest3
		searchAction.setQuery("Edward");
		searchStartTime.set(2013, 10, 26, 0, 0, 0);
		assertEquals(TasksManager.getInstance().executeCommand(searchAction), "Search Matches: \n\nTodos: \n1. [Status: undone] Meet Edward for catch up session\n\n");		
		
		//DELETE TESTS
		DeleteAction deleteAction = new DeleteAction();
		TasksManager.getInstance().executeCommand(displayAction);
		ArrayList<Integer> deleteRefNum = new ArrayList<Integer>();
		
		//deleteTest1
		deleteRefNum.add(3);
		deleteAction.setReferenceNumber(deleteRefNum);
		assertEquals(TasksManager.getInstance().executeCommand(deleteAction),"Deleted [3] successfully \n\n");
		
		//display
		assertEquals(TasksManager.getInstance().executeCommand(displayAction), "Schedules: \n1. [Mon, Nov 25, '13] [12:00 PM - 11:59 PM] swimming at Community Centre\n\nDeadlines: \n2. [Sat, Nov 16, '13] [by 11:59 PM] [Status: done&nbsp&nbsp] reply Edward\n\nTodos: \n3. [Status: done&nbsp&nbsp] clean my room\n4. [Status: undone] complete CS2106 project\n5. [Status: undone] learn swimming\n\n");
		
		//deleteTest2
		deleteRefNum.remove((Integer)3);
		deleteRefNum.add(1);
		deleteRefNum.add(2);
		assertEquals(TasksManager.getInstance().executeCommand(deleteAction),"Deleted [1, 2] successfully \n\n");
		
		//display
		assertEquals(TasksManager.getInstance().executeCommand(displayAction), "Todos: \n1. [Status: done&nbsp&nbsp] clean my room\n2. [Status: undone] complete CS2106 project\n3. [Status: undone] learn swimming\n\n");
		
		//DELETE UNDO TEST
		assertEquals(TasksManager.getInstance().executeCommand(new UndoAction()), "Delete command successfully undone\n\n");
		
		//display
		assertEquals(TasksManager.getInstance().executeCommand(displayAction), "Schedules: \n1. [Mon, Nov 25, '13] [12:00 PM - 11:59 PM] swimming at Community Centre\n\nDeadlines: \n2. [Sat, Nov 16, '13] [by 11:59 PM] [Status: done&nbsp&nbsp] reply Edward\n\nTodos: \n3. [Status: done&nbsp&nbsp] clean my room\n4. [Status: undone] complete CS2106 project\n5. [Status: undone] learn swimming\n\n");
		
		//UPDATE TESTS
		UpdateAction updateAction = new UpdateAction();
		int updateRefNum = 1;
		updateAction.setReferenceNumber(updateRefNum);
		Calendar updateStartTime = Calendar.getInstance();
		Calendar updateEndTime = Calendar.getInstance();
		updateStartTime.set(2013, 10, 31, 14, 0, 0);
		updateEndTime.set(2013, 10, 31, 15, 0, 0);
		updateAction.setUpdatedStartTime(updateStartTime);
		updateAction.setUpdatedEndTime(updateEndTime);
		updateAction.setUpdatedQuery("Gymming");
		updateAction.setUpdatedLocationQuery("gym");
		
		//updateTest1
		assertEquals(TasksManager.getInstance().executeCommand(updateAction), "Updated 1 to Gymming successfully\n\n");
		
		//display
		displayAction.setDescription("schedules");
		assertEquals(TasksManager.getInstance().executeCommand(displayAction), "Schedules: \n1. [Sun, Dec 01, '13] [02:00 PM - 03:00 PM] Gymming at gym\n\n");
		displayAction.setDescription("all");
		
		//updateTest2
		TasksManager.getInstance().executeCommand(displayAction);
		updateAction.setUpdatedStartTime(null);
		updateAction.setUpdatedEndTime(null);
		updateAction.setUpdatedQuery("Finish reading Harry Potter");
		updateAction.setUpdatedLocationQuery("");
		updateRefNum = 5;
		updateAction.setReferenceNumber(updateRefNum);
		assertEquals(TasksManager.getInstance().executeCommand(updateAction), "Updated 5 to Finish reading Harry Potter successfully\n\n");
		
		//display
		displayAction.setDescription("todos");
		assertEquals(TasksManager.getInstance().executeCommand(displayAction), "Todos: \n1. [Status: undone] Finish reading Harry Potter\n2. [Status: done&nbsp&nbsp] clean my room\n3. [Status: undone] complete CS2106 project\n\n");
		
		//UPDATE UNDO TEST
		assertEquals(TasksManager.getInstance().executeCommand(new UndoAction()),"Update command successfully undone\n\n");
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\JUnitTestOutput.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\JUnitTestOutput.java
	 */

	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\JUnitTestOutput.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\Schedule.java
	 */

package com.licensetokil.atypistcalendar.tasksmanager;

import java.text.SimpleDateFormat;
import java.util.Calendar;

public class Schedule extends Task implements Comparable<Schedule>, Cloneable {
	private static final String OUTPUT_FORMAT = "[%s] [%s - %s] %s";

	private String remoteId;
	private TaskType taskType;
	private int uniqueId;
	private Calendar lastModifiedDate;
	private Calendar startTime;
	private Calendar endTime;
	private String description;
	private String place;

	public Schedule(int uniqueId, Calendar startTime, Calendar endTime,
			String description, String place, Calendar lastModifiedDate) {
		this.taskType = TaskType.SCHEDULE;
		this.uniqueId = uniqueId;
		this.startTime = startTime;
		this.endTime = endTime;
		this.description = description;
		this.place = place;
		this.lastModifiedDate = lastModifiedDate;
	}

	public Schedule() {
	}

	public String getRemoteId() {
		return remoteId;
	}

	public TaskType getTaskType() {
		return taskType;
	}

	public int getUniqueId() {
		return uniqueId;
	}

	public Calendar getLastModifiedDate() {
		return lastModifiedDate;
	}

	public Calendar getStartTime() {
		return startTime;
	}

	public Calendar getEndTime() {
		return endTime;
	}

	public String getDescription() {
		return description;
	}

	public String getPlace() {
		return place;
	}

	public void setRemoteId(String remoteId) {
		this.remoteId = remoteId;
	}

	public void setTaskType(TaskType t) {
		this.taskType = t;
	}

	public void setUniqueId(int uniqueId) {
		this.uniqueId = uniqueId;
	}

	public void setStartTime(Calendar st) {
		this.startTime = st;
	}

	public void setEndTime(Calendar st) {
		this.endTime = st;
	}

	public void setDescription(String d) {
		this.description = d;
	}

	public void setPlace(String p) {
		this.place = p;
	}

	public void setLastModifiedDate(Calendar lastModifiedDate) {
		this.lastModifiedDate = lastModifiedDate;
	}

	public String toString() {
		if (place.equals(EMPTY_STRING)) {
			return TaskType.SCHEDULE + DELIMITER + uniqueId + DELIMITER
					+ startTime.getTime() + DELIMITER + endTime.getTime()
					+ DELIMITER + description + DELIMITER + BLANK_SPACE
					+ DELIMITER + lastModifiedDate.getTime() + DELIMITER
					+ remoteId;
		}
		return TaskType.SCHEDULE + DELIMITER + uniqueId + DELIMITER
				+ startTime.getTime() + DELIMITER + endTime.getTime()
				+ DELIMITER + description + DELIMITER + place + DELIMITER
				+ lastModifiedDate.getTime() + DELIMITER + remoteId;
	}

	public String outputStringForDisplay() {
		SimpleDateFormat formatTime = new SimpleDateFormat("hh:mm a");
		SimpleDateFormat formatDay = new SimpleDateFormat("EEE, MMM dd, ''yy");

		String output = String.format(OUTPUT_FORMAT,
				formatDay.format(startTime.getTime()),
				formatTime.format(startTime.getTime()),
				formatTime.format(endTime.getTime()), description);
		if (!place.equals(EMPTY_STRING)) {
			output = String.format(DISPLAY_PLACE_NOT_EMPTY, output,
					this.getPlace());
		}

		return output;
	}

	public int compareTo(Schedule s) {
		return startTime.compareTo(s.getStartTime());
	}

	@Override
	public Object clone() {
		Schedule clonedObject = new Schedule();
		clonedObject.remoteId = this.remoteId;
		clonedObject.taskType = this.taskType;
		clonedObject.uniqueId = this.uniqueId;
		clonedObject.description = this.description;
		clonedObject.place = this.place;
		clonedObject.startTime = (Calendar) this.startTime.clone();
		clonedObject.endTime = (Calendar) this.endTime.clone();
		clonedObject.lastModifiedDate = (Calendar) this.lastModifiedDate
				.clone();

		return clonedObject;
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\Schedule.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\Schedule.java
	 */


	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\Schedule.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\Task.java
	 */

package com.licensetokil.atypistcalendar.tasksmanager;

import java.util.Calendar;

public abstract class Task implements Cloneable{
	protected String remoteId;
	protected TaskType taskType;
	protected int uniqueId;
	protected Calendar lastModifiedDate;
	protected String place;
	protected String description;
	protected static final String DELIMITER = "@s";
	protected static final String EMPTY_STRING = "";
	protected static final String DONE_ALIGN = "done&nbsp&nbsp";
	protected static final String DONE_NO_ALIGN = "done";
	protected static final String DISPLAY_PLACE_NOT_EMPTY = "%s at %s";
	protected static final String BLANK_SPACE = " ";
	
	public abstract String getRemoteId();
	public abstract TaskType getTaskType();
	public abstract String getDescription();
	public abstract int getUniqueId();
	public abstract Calendar getLastModifiedDate();
	public abstract String getPlace();
	public abstract void setPlace(String place);
	public abstract void setDescription(String description);
	public abstract void setRemoteId(String remoteId);
	public abstract void setLastModifiedDate(Calendar lastModifiedDate);
	public abstract void setUniqueId(int uniqueId);
	public abstract void setTaskType(TaskType t);
	public abstract String toString();
	public abstract String outputStringForDisplay();
	@Override
	public abstract Object clone();
}
	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\Task.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\Task.java
	 */


	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\Task.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\TaskNotFoundException.java
	 */

package com.licensetokil.atypistcalendar.tasksmanager;

public class TaskNotFoundException extends Exception {
	
	private static final long serialVersionUID = 1L;

	public TaskNotFoundException(){
		
	}
	
	public TaskNotFoundException(String message){
		super(message);
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\TaskNotFoundException.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\TaskNotFoundException.java
	 */

	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\TaskNotFoundException.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\TasksManager.java
	 */

package com.licensetokil.atypistcalendar.tasksmanager;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.licensetokil.atypistcalendar.parser.AddAction;
import com.licensetokil.atypistcalendar.parser.DeleteAction;
import com.licensetokil.atypistcalendar.parser.DisplayAction;
import com.licensetokil.atypistcalendar.parser.LocalAction;
import com.licensetokil.atypistcalendar.parser.LocalActionType;
import com.licensetokil.atypistcalendar.parser.MarkAction;
import com.licensetokil.atypistcalendar.parser.SearchAction;
import com.licensetokil.atypistcalendar.parser.UpdateAction;

public class TasksManager {

	private static Logger logger = Logger.getLogger("TasksManager");

	private static final String ADD_WARNING_CLASH = "Warning: schedule clashes with the following event(s):\n";
	private static final String ADD_PREFIX = "Added: \n";

	// Strings for display function
	private static final String DISPLAY_NO_MATCHES = "No display matches! Nothing to be displayed\n\n";
	private static final String DISPLAY_TYPE_SCHEDULE = "schedules";
	private static final String DISPLAY_TYPE_DEADLINE = "deadlines";
	private static final String DISPLAY_TYPE_TODO = "todos";
	private static final String DISPLAY_TYPE_ALL = "all";
	private static final String DISPLAY_TYPE_EMPTY = "";
	private static final String DISPLAY_SCHEDULE_PREFIX = "Schedules: \n";
	private static final String DISPLAY_DEADLINE_PREFIX = "Deadlines: \n";
	private static final String DISPLAY_TODO_PREFIX = "Todos: \n";
	private static final String DISPLAY_ALIGNMENT_DOT = ". ";
	private static final String DISPLAY_NONALIGNMENT_DOT = ".";

	private static final String DELETE_SUCCESSFUL = "Deleted %s successfully \n\n";
	private static final String DELETE_ALL = "Deleted all successfully\n\n";
	private static final String INVALID_NUMBER_INPUT = "Your number input is invalid and out of range. Please try again!\n";

	// Strings for update function
	private static final String UPDATE_TYPE_CLASH = "Update was unsuccessful due to clash in event type. Please try again!\n\n";
	private static final String UPDATE_SUCCESSFUL = "Updated %s to %s successfully\n\n";
	private static final String UPDATE_WARNING_CLASH = "Warning: The following events clashes after update:\n";

	private static final String MARK_SUCCESSFUL = "Marked %s as %s\n\n";
	private static final String MARK_SCHEDULE_ERROR = "The event that you are trying to mark is a schedule. Please try again!\n\n";
	private static final String MARK_UNDONE = "undone";

	// Strings for search function
	private static final String SEARCH_UNFOUND = "No search matches found!\n\n";
	private static final String SEARCH_PREFIX = "Search Matches: \n\n";

	// Strings for undo function
	private static final String UNDO_DELETE_SUCCESSFUL = "Delete command successfully undone\n\n";
	private static final String UNDO_MARK_SUCCESSFUL = "Mark command successfully undone\n\n";
	private static final String UNDO_UPDATE_SUCCESSFUL = "Update command successfully undone\n\n";
	private static final String UNDO_ADD_SUCCESSFUL = "Add command successfully undone\n\n";

	private static final String UNDO_DISALLOWED = "Undo command is not allowed\n\n";

	// Miscellaneous Strings
	private static final String EMPTY_STRING = "";
	private static final String BLANK_SPACE = " ";
	private static final String NULL_STRING = "null";
	private static final String DELIMITER = "@s";
	private static final String NEWLINE = "\n";
	private static final String UNIQUEID = "uniqueId";

	private static final String ERROR_MESSAGE = "Error in executing your command. Please try again! \n\n";

	private static TasksManager TM;

	private static ArrayList<Schedule> allSchedules = new ArrayList<Schedule>();
	private static ArrayList<Deadline> allDeadlines = new ArrayList<Deadline>();
	private static ArrayList<Todo> allTodos = new ArrayList<Todo>();

	private static ArrayList<Schedule> requestedSchedules = new ArrayList<Schedule>();
	private static ArrayList<Deadline> requestedDeadlines = new ArrayList<Deadline>();
	private static ArrayList<Todo> requestedTodos = new ArrayList<Todo>();

	private static ArrayList<Task> deletedTasks = new ArrayList<Task>();

	private static ArrayList<Task> markUndoList;
	private static Task updateOriginalTask = new Schedule();

	private static LocalAction lastAction;
	private static Task lastTaskCreated;

	private static Hashtable<Integer, Task> selectedTasks = new Hashtable<Integer, Task>();

	private static int uniqueId = 0;

	private static File file = new File("ATC.txt");

	// private constructor
	private TasksManager() {
	}

	// Method to access a single instance
	public static TasksManager getInstance() {
		if (TM == null) {
			TM = new TasksManager();
		}
		return TM;
	}

	// function for google calendar
	public ArrayList<Task> cloneAllTasks() {
		logger.log(Level.INFO, "In cloneAllTasks");
		ArrayList<Task> allTasks = new ArrayList<Task>();

		for (Schedule s : allSchedules) {
			logger.log(Level.INFO, "cloning schedule " + s);
			allTasks.add((Schedule) s.clone());
		}

		for (Deadline d : allDeadlines) {
			logger.log(Level.INFO, "cloning deadline " + d);
			allTasks.add((Deadline) d.clone());
		}

		for (Todo t : allTodos) {
			logger.log(Level.INFO, "cloning todo " + t);
			allTasks.add((Todo) t.clone());
		}

		return allTasks;
	}
	
	public void initialize() {
		try {
			logger.log(Level.INFO,
					"Initialising files and transferring data from files to temporary memory");
	
			BufferedReader reader = new BufferedReader(new FileReader(file));
			String currLine;
			String[] fileData;
			
			// To import all tasks from file to ArrayList
			while ((currLine = reader.readLine()) != null) {
				fileData = currLine.split(DELIMITER);
				assert fileData[0] !=null;
				if (fileData[0].equals(TaskType.SCHEDULE.toString())) {
					Schedule s = new Schedule(Integer.parseInt(fileData[1]),
							convertTimeFromStringToCalendar(fileData[2]),
							convertTimeFromStringToCalendar(fileData[3]),
							fileData[4], fileData[5],
							convertTimeFromStringToCalendar(fileData[6]));
					allSchedules.add(s);
	
					logger.log(Level.INFO,
							"Added schedule into temporary memory");
					if (fileData[5].equals(BLANK_SPACE)) {
						logger.log(Level.INFO,
								"No place indicated. Setting place to empty string");
						s.setPlace(EMPTY_STRING);
	
					}
					if (fileData[7].equals(NULL_STRING)) {
						logger.log(Level.INFO,
								"No remote ID for schedule indicated. Setting remoteId to null");
						s.setRemoteId(null);
	
					} else {
						s.setRemoteId(fileData[7]);
					}
				} else if (fileData[0].equals(TaskType.DEADLINE.toString())) {
					Deadline d = new Deadline(Integer.parseInt(fileData[1]),
							convertTimeFromStringToCalendar(fileData[2]),
							fileData[3], fileData[4], fileData[5],
							convertTimeFromStringToCalendar(fileData[6]));
					allDeadlines.add(d);
					logger.log(Level.INFO,
							"Added deadline into temporary memory");
					if (fileData[4].equals(BLANK_SPACE)) {
						logger.log(Level.INFO,
								"No place indicated. Setting place to empty string");
						d.setPlace(EMPTY_STRING);
	
					}
					if (fileData[7].equals(NULL_STRING)) {
						logger.log(Level.INFO,
								"No remote ID for deadline indicated. Setting remoteId to null");
						d.setRemoteId(null);
					} else {
						logger.log(Level.INFO, "setting remote ID");
						d.setRemoteId(fileData[7]);
					}
				} else if (fileData[0].equals(TaskType.TODO.toString())) {
					Todo td = new Todo(Integer.parseInt(fileData[1]),
							fileData[2], fileData[3], fileData[4],
							convertTimeFromStringToCalendar(fileData[5]));
					allTodos.add(td);
					logger.log(Level.INFO, "Added todo into temporary memory");
					if (fileData[3].equals(BLANK_SPACE)) {
						logger.log(Level.INFO,
								"No place indicated. Setting place to empty string");
						td.setPlace(EMPTY_STRING);
	
					}
					if (fileData[6].equals(NULL_STRING)) {
						logger.log(Level.INFO,
								"No remote ID for deadline indicated. Setting remoteId to null");
						td.setRemoteId(null);
					} else {
						logger.log(Level.INFO, "setting remote ID");
						td.setRemoteId(fileData[6]);
					}
				} else if (fileData[0].equals(UNIQUEID)) {
					uniqueId = Integer.parseInt(fileData[1]); // the last
																// uniqueId
																// is stored
																// at the
																// end of
																// the file
																// and hence
																// needs to
																// be
																// retrieved
																// when the
																// application
																// is
																// reopened.
					logger.log(Level.INFO, "Tracking the last uniqueID");
				}
			}
			fileSync();
			reader.close();
		} catch (Exception e) {
			logger.log(Level.WARNING, "Exception detected");
			System.err.println("Error: " + e.getMessage());
		}
	}

	public void updateCorrespondingTaskRemoteId(int uniqueId, String remoteId)
			throws TaskNotFoundException {
		logger.log(Level.INFO, "In updateCorrespondingTaskRemoteId function");
		Task t = findTaskFromUniqueId(uniqueId);
		t.setRemoteId(remoteId);
	}

	public String executeCommand(LocalAction ac) {
		logger.log(Level.INFO, "In executeCommand function");
	
		if (ac.getType() == LocalActionType.ADD) {
			logger.log(Level.INFO, "Command identified as add");
			Task t = classify((AddAction) ac);
			lastAction = ac;
			return add(t);
		}
	
		else if (ac.getType() == LocalActionType.DISPLAY) {
			logger.log(Level.INFO, "Command identified as display");
			return display((DisplayAction) ac);
		}
	
		else if (ac.getType() == LocalActionType.SEARCH) {
			logger.log(Level.INFO, "Command identified as search");
			return search((SearchAction) ac);
		}
	
		else if (ac.getType() == LocalActionType.DELETE) {
			logger.log(Level.INFO, "Command identified as delete");
			String output = delete((DeleteAction) ac);
			if (!output.equals(INVALID_NUMBER_INPUT)) {
				lastAction = ac;
			}
			return output;
		}
	
		else if (ac.getType() == LocalActionType.UPDATE) {
			logger.log(Level.INFO, "Command identified as update");
			lastAction = ac;
			return update((UpdateAction) ac);
		}
	
		else if (ac.getType() == LocalActionType.MARK) {
			logger.log(Level.INFO, "Command identified as mark");
			String output = mark((MarkAction) ac);
			if (!output.equals(INVALID_NUMBER_INPUT)
					&& !output.equals(MARK_SCHEDULE_ERROR)) {
				lastAction = ac;
			}
			return output;
		}
	
		else if (ac.getType() == LocalActionType.UNDO) {
			logger.log(Level.INFO, "Command identified as undo");
			if (lastAction instanceof AddAction) {
				lastAction = ac;
				return addUndo();
			} else if (lastAction instanceof UpdateAction) {
				lastAction = ac;
				return updateUndo();
			} else if (lastAction instanceof DeleteAction) {
				lastAction = ac;
				return deleteUndo();
			} else if (lastAction instanceof MarkAction) {
				lastAction = ac;
				return markUndo();
			} else {
				return UNDO_DISALLOWED;
			}
		}
		return ERROR_MESSAGE;
	
	}

	public Todo addTodoFromGoogle(String description, String location,
			Calendar lastModifiedDate, String remoteId) {
		logger.log(Level.INFO, "In addTodoFromGoogle function");
		Todo todo = new Todo(++uniqueId, description, location, MARK_UNDONE,
				lastModifiedDate);
		todo.setRemoteId(remoteId);
		add(todo);
		return todo;
	}

	public Deadline addDeadlineFromGoogle(Calendar endTime, String description,
			String location, Calendar lastModifiedDate, String remoteId) {
		logger.log(Level.INFO, "In addDeadlineFromGoogle function");
		Deadline deadline = new Deadline(++uniqueId, endTime, description,
				location, MARK_UNDONE, lastModifiedDate);
		deadline.setRemoteId(remoteId);
		add(deadline);
		return deadline;
	}

	public Schedule addScheduleFromGoogle(Calendar startTime, Calendar endTime,
			String description, String location, Calendar lastModifiedDate,
			String remoteId) {
		logger.log(Level.INFO, "In addScheduleFromGoogle function");
		Schedule schedule = new Schedule(++uniqueId, startTime, endTime,
				description, location, lastModifiedDate);
		schedule.setRemoteId(remoteId);
		add(schedule);
		return schedule;
	}

	public void deleteGoogleTask(int uniqueId) throws TaskNotFoundException {
		logger.log(Level.INFO, "In deleteGoogleTask function");
		Task t = findTaskFromUniqueId(uniqueId);
		if (t.getTaskType() == TaskType.SCHEDULE) {
			logger.log(Level.INFO, "Removing schedule " + t);
			allSchedules.remove(t);
		} else if (t.getTaskType() == TaskType.DEADLINE) {
			logger.log(Level.INFO, "Removing deadline " + t);
			allDeadlines.remove(t);
		} else if (t.getTaskType() == TaskType.TODO) {
			logger.log(Level.INFO, "Removing todo " + t);
			allTodos.remove(t);
		} else {
			logger.log(Level.WARNING, "Task not found");
			throw new TaskNotFoundException();
		}
	
		logger.log(Level.INFO, "Preparing for file sync");
		fileSync();
	}

	public void updateGoogleTask(Task t) throws TaskNotFoundException {
		logger.log(Level.INFO, "In updateGoogleTask");
		Task updateTask = findTaskFromUniqueId(t.getUniqueId());
		if (t.getTaskType() == TaskType.SCHEDULE) {
			logger.log(Level.INFO, "Updating schedule " + t);
			allSchedules.set(allSchedules.indexOf(updateTask), (Schedule) t);
		} else if (t.getTaskType() == TaskType.DEADLINE) {
			logger.log(Level.INFO, "Updating deadline " + t);
			allDeadlines.set(allDeadlines.indexOf(updateTask), (Deadline) t);
		} else if (t.getTaskType() == TaskType.TODO) {
			logger.log(Level.INFO, "Updating todo " + t);
			allTodos.set(allTodos.indexOf(updateTask), (Todo) t);
		} else {
			logger.log(Level.WARNING, "Task not found");
			throw new TaskNotFoundException();
		}
	}

	public ArrayList<Schedule> checkForScheduleClashes(Schedule s) {
		logger.log(Level.INFO, "In check for schedule clashes");
		ArrayList<Schedule> clashedSchedules = new ArrayList<Schedule>();
		for (Schedule sc : allSchedules) {
			if ((s.getStartTime().after(sc.getStartTime()) && s.getEndTime()
					.before(sc.getEndTime()))
					|| (s.getStartTime().compareTo(sc.getStartTime()) == 0 || (s
							.getEndTime().compareTo(sc.getEndTime()) == 0))) {
				logger.log(Level.INFO, "Clashed schedule found: " + sc);
				if (updateOriginalTask != null
						&& updateOriginalTask.getUniqueId() != sc.getUniqueId()) {
					clashedSchedules.add(sc);
				}
			}
		}
	
		return clashedSchedules;
	}

	public void exit() {
		logger.log(Level.INFO, "In exit function");
		BufferedWriter writer = null;
		try {
			logger.log(Level.INFO, "Preparing for file sync");
			fileSync();
			writer = new BufferedWriter(new FileWriter(file, true));
			logger.log(Level.INFO, "Writing into file the last uniqueId"
					+ uniqueId);
			writer.write(UNIQUEID + DELIMITER + uniqueId);
			writer.newLine();
		} catch (Exception e) {
			logger.log(Level.WARNING, "Error detected " + e.getMessage());
		} finally {
			try {
				logger.log(Level.INFO, "Closing buffered writer");
				writer.close();
			} catch (IOException e) {
				logger.log(
						Level.WARNING,
						"Unable to close buffered writer due to error: "
								+ e.getMessage());
			}
		}
	}

	private Calendar convertTimeFromStringToCalendar(String time) {
		StringTokenizer st = new StringTokenizer(time);
		st.nextToken(); // unused token: day is not stored.

		logger.log(Level.INFO,
				"Converting time from calendar type to string type");
		int month = determineMonth(st.nextToken());
		int date = Integer.parseInt(st.nextToken());

		logger.log(Level.INFO, "Converted month and date");

		StringTokenizer stHrAndMin = new StringTokenizer(st.nextToken(), ":");
		int hour = Integer.parseInt(stHrAndMin.nextToken());
		int min = Integer.parseInt(stHrAndMin.nextToken());
		int sec = Integer.parseInt(stHrAndMin.nextToken());

		logger.log(Level.INFO, "Converted hour and min");
		st.nextToken(); // unused token SGT

		int year = Integer.parseInt(st.nextToken());

		Calendar cal = Calendar.getInstance();
		cal.set(year, month, date, hour, min, sec);
		cal.set(Calendar.MILLISECOND, 0); // for google calendar purpose

		return cal;
	}

	// method to get the number that corresponds to the month of the year.
	// returns -1 if the string parameter is not determinable.
	private int determineMonth(String month) {
		logger.log(Level.INFO, "Converting month from String to int");
		switch (month) {
		case "Jan":
			logger.log(Level.INFO, "Detected month as JAN");
			return 0;
		case "Feb":
			logger.log(Level.INFO, "Detected month as FEB");
			return 1;
		case "Mar":
			logger.log(Level.INFO, "Detected month as MAR");
			return 2;
		case "Apr":
			logger.log(Level.INFO, "Detected month as APR");
			return 3;
		case "May":
			logger.log(Level.INFO, "Detected month as MAY");
			return 4;
		case "Jun":
			logger.log(Level.INFO, "Detected month as JUN");
			return 5;
		case "Jul":
			logger.log(Level.INFO, "Detected month as JUL");
			return 6;
		case "Aug":
			logger.log(Level.INFO, "Detected month as AUG");
			return 7;
		case "Sep":
			logger.log(Level.INFO, "Detected month as SEP");
			return 8;
		case "Oct":
			logger.log(Level.INFO, "Detected month as OCT");
			return 9;
		case "Nov":
			logger.log(Level.INFO, "Detected month as NOV");
			return 10;
		case "Dec":
			logger.log(Level.INFO, "Detected month as DEC");
			return 11;
		default:
			logger.log(Level.WARNING, "No month detected");
			return -1;
		}
	}

	// Method that classifies the user add input into three types of task:
	// schedules, deadlines, and todos. Deadlines and Todos are default undone.
	private Task classify(AddAction action) {
		Task t;
		if (action.getStartTime() == null) {
			if (action.getEndTime() == null) {
				logger.log(Level.INFO,
						"Creating todo. No start time and end time detected");
				t = new Todo(++uniqueId, action.getDescription(),
						action.getPlace(), MARK_UNDONE, Calendar.getInstance());
			} else {
				logger.log(Level.INFO,
						"Creating deadline. No start time detected");
				t = new Deadline(++uniqueId, action.getEndTime(),
						action.getDescription(), action.getPlace(),
						MARK_UNDONE, Calendar.getInstance());
			}
		} else {
			logger.log(Level.INFO,
					"Creating schedule. Both start time and end time detected");
			t = new Schedule(++uniqueId, action.getStartTime(),
					action.getEndTime(), action.getDescription(),
					action.getPlace(), Calendar.getInstance());
		}

		return t;
	}

	// Method for adding classified tasks into the calendar
	private String add(Task t) {

		logger.log(Level.INFO, "In TM add function, adding task");

		String output = EMPTY_STRING;
		ArrayList<Schedule> sc;

		output = ADD_PREFIX + t.outputStringForDisplay() + NEWLINE;

		if (t.getTaskType().equals(TaskType.SCHEDULE)) {
			if (!(sc = checkForScheduleClashes((Schedule) t)).isEmpty()) {
				logger.log(Level.INFO, "Clashed schedules detected");
				output += NEWLINE + ADD_WARNING_CLASH;
				System.out.println("debugdebug");
				for (Schedule s : sc) {
					logger.log(Level.INFO, "Printing all clashed schedules");
					output += s.outputStringForDisplay() + NEWLINE;
				}
			}
			logger.log(Level.INFO, "Adding schedule");
			allSchedules.add((Schedule) t);
		} else if (t.getTaskType().equals(TaskType.DEADLINE)) {
			logger.log(Level.INFO, "Adding deadline");
			allDeadlines.add((Deadline) t);

		} else if (t.getTaskType().equals(TaskType.TODO)) {
			logger.log(Level.INFO, "Adding todo");
			allTodos.add((Todo) t); 
		}

		lastTaskCreated = t;
		assert lastTaskCreated!=null;
		fileSync();

		return output + NEWLINE;

	}

	private String addUndo() {

		logger.log(
				Level.INFO,
				"In add undo function. Removing the last task added into the function from arraylist.");
		allSchedules.remove(lastTaskCreated);
		allDeadlines.remove(lastTaskCreated);
		allTodos.remove(lastTaskCreated);

		logger.log(Level.INFO, "Preparing for file sync");
		fileSync();

		return UNDO_ADD_SUCCESSFUL;
	}
	
	private String display(DisplayAction ac) {
		logger.log(Level.INFO,
				"In display function. Clearing all previously requested tasks by the user");
		requestedSchedules.clear();
		requestedDeadlines.clear();
		requestedTodos.clear();
		selectedTasks.clear();

		String output = EMPTY_STRING;

		switch (ac.getDescription()) {

		// If user wants to display schedules only
		case DISPLAY_TYPE_SCHEDULE:
			logger.log(Level.INFO, "Display schedules requested");
			for (Schedule s : allSchedules) {
				if ((s.getStartTime().after(ac.getStartTime()) && s
						.getEndTime().before(ac.getEndTime()))
						|| (s.getStartTime().compareTo(ac.getStartTime()) == 0 || (s
								.getEndTime().compareTo(ac.getEndTime()) == 0))) {
					logger.log(Level.INFO,
							"schedule within specified timeframe found. Adding in particular schedule");
					requestedSchedules.add(s);
				}
			}
			break;

		// If user wants to display deadlines only
		case DISPLAY_TYPE_DEADLINE:
			logger.log(Level.INFO, "Display deadlines requested");
			for (Deadline d : allDeadlines) {
				if (ac.getStatus().equals(EMPTY_STRING)) {
					if ((d.getEndTime().after(ac.getStartTime()) && d
							.getEndTime().before(ac.getEndTime()))
							|| (d.getEndTime().compareTo(ac.getStartTime()) == 0)
							|| (d.getEndTime().compareTo(ac.getEndTime()) == 0)) {
						logger.log(Level.INFO,
								"deadline within specified timeframe found. Adding in particular deadline");
						requestedDeadlines.add(d);
					}
				} else {
					if (((d.getEndTime().after(ac.getStartTime()) && d
							.getEndTime().before(ac.getEndTime()))
							|| (d.getEndTime().compareTo(ac.getStartTime()) == 0) || (d
							.getEndTime().compareTo(ac.getEndTime()) == 0))
							&& d.getStatus().equals(ac.getStatus())) {
						logger.log(
								Level.INFO,
								"deadline within specified timeframe and status found. Adding in particular deadline");
						requestedDeadlines.add(d);
					}
				}
			}
			break;

		// If user wants to display todos only
		case DISPLAY_TYPE_TODO:
			logger.log(Level.INFO, "Display todos requested");
			for (Todo td : allTodos) {
				if (ac.getStatus().equals(EMPTY_STRING)) {
					logger.log(Level.INFO,
							"Adding all todos with no specified status");
					requestedTodos.add(td);
				} else {
					if (td.getStatus().equals(ac.getStatus())) {
						logger.log(Level.INFO,
								"Adding all todos with specified status");
						requestedTodos.add(td);
					}
				}
			}
			break;

		// If user wants to display all types
		case DISPLAY_TYPE_ALL:
			logger.log(Level.INFO, "Display all requested");
			for (Schedule s : allSchedules) {
				if ((s.getStartTime().after(ac.getStartTime()) && s
						.getEndTime().before(ac.getEndTime()))
						|| (s.getStartTime().compareTo(ac.getStartTime()) == 0 || (s
								.getEndTime().compareTo(ac.getEndTime()) == 0))) {
					logger.log(Level.INFO,
							"schedule within specified timeframe found. Adding in particular schedule");
					requestedSchedules.add(s);
				}
			}
			for (Deadline d : allDeadlines) {
				if ((d.getEndTime().after(ac.getStartTime()) && d
						.getEndTime().before(ac.getEndTime()))
						|| (d.getEndTime().compareTo(ac.getStartTime()) == 0)
						|| (d.getEndTime().compareTo(ac.getEndTime()) == 0)) {
					logger.log(Level.INFO,
							"deadline within specified timeframe found. Adding in particular deadline");
					requestedDeadlines.add(d);
				}
			}
			if (ac.getEndTime().get(Calendar.YEAR) == 2099) {
				for (Todo td : allTodos) {
					logger.log(Level.INFO, "adding all todos");
					requestedTodos.add(td);
				}
			}
			break;
		case DISPLAY_TYPE_EMPTY:
			logger.log(Level.INFO, "Display done or undone requested");
			for (Deadline d : allDeadlines) {
				if (d.getStatus().equals(ac.getStatus())) {
					requestedDeadlines.add(d);
				}
			}
			for (Todo td : allTodos) {
				if (td.getStatus().equals(ac.getStatus())) {
					requestedTodos.add(td);
				}
			}

		default:
			break;
		}

		return displayOutput(output);
	}

	private String alignNumbersAndText(int count) {
		String strCount;
		if (count < 10) {
			logger.log(Level.INFO,
					"Count is less than 10. Aligning output text");
			strCount = count + DISPLAY_ALIGNMENT_DOT;
		} else {
			logger.log(Level.INFO, "Count is now more than 10");
			strCount = count + DISPLAY_NONALIGNMENT_DOT;
		}
		return strCount;
	}

	private String displayOutput(String output) {
		int count = 1;
		String strCount = EMPTY_STRING;

		logger.log(Level.INFO, "Sorting schedules in temporary memory");
		Collections.sort(requestedSchedules);
		Collections.sort(requestedDeadlines);
		Collections.sort(requestedTodos);

		if (!requestedSchedules.isEmpty()) {
			logger.log(Level.INFO,
					"Adding schedules to be displayed into output String");
			output = output + DISPLAY_SCHEDULE_PREFIX;
			for (Schedule s : requestedSchedules) {
				strCount = alignNumbersAndText(count);
				output = output + strCount + s.outputStringForDisplay()
						+ NEWLINE;
				selectedTasks.put(count, s);
				count++;
			}
			output = output + NEWLINE;
		}

		if (!requestedDeadlines.isEmpty()) {
			logger.log(Level.INFO,
					"Adding deadlines to be displayed into output String");
			output = output + DISPLAY_DEADLINE_PREFIX;
			for (Deadline d : requestedDeadlines) {
				strCount = alignNumbersAndText(count);
				output = output + strCount + d.outputStringForDisplay()
						+ NEWLINE;
				selectedTasks.put(count, d);
				count++;
			}

			output = output + NEWLINE;
		}

		if (!requestedTodos.isEmpty()) {
			logger.log(Level.INFO,
					"Adding todos to be displayed into output String");
			output = output + DISPLAY_TODO_PREFIX;
			for (Todo td : requestedTodos) {
				strCount = alignNumbersAndText(count);
				output = output + strCount + td.outputStringForDisplay()
						+ NEWLINE;
				selectedTasks.put(count, td);
				count++;
			}

			output = output + NEWLINE;
		}

		if (output.equals(EMPTY_STRING)) {
			logger.log(Level.INFO,
					"No display matches detected. Reuturning no match");
			output = DISPLAY_NO_MATCHES;
		}
		
		assert output!=EMPTY_STRING;

		return output;
	}

	private boolean checkValidReferenceNumbers(ArrayList<Integer> refNum) {
		assert !refNum.isEmpty();
		for (Integer num : refNum) {
			if (num > selectedTasks.size() || num <= 0) {
				return false;
			}
		}
		return true;
	}

	private String delete(DeleteAction ac) {
		logger.log(Level.INFO, "In delete function");
		deletedTasks.clear();

		if (ac.getReferenceNumber().get(0) != -1) {
			logger.log(Level.INFO, "Normal delete function");
			if (checkValidReferenceNumbers(ac.getReferenceNumber())) {
				for (Integer num : ac.getReferenceNumber()) {

					Task t = selectedTasks.get(num);
					deletedTasks.add(t);

					if (t instanceof Schedule) {
						logger.log(Level.INFO, "Removing schedule: " + t);
						allSchedules.remove(t);
						requestedSchedules.remove(t);
					} else if (t instanceof Deadline) {
						logger.log(Level.INFO, "Removing deadline: " + t);
						allDeadlines.remove(t);
						requestedDeadlines.remove(t);
					} else if (t instanceof Todo) {
						logger.log(Level.INFO, "Removing todo: " + t);
						allTodos.remove(t);
						requestedTodos.remove(t);
					}

					t.setLastModifiedDate(Calendar.getInstance());
				}
			} else {
				logger.log(Level.INFO,
						"Number input exceeds displayed number of output. Returning error");
				return INVALID_NUMBER_INPUT;
			}
		} else {
			logger.log(Level.INFO, "Delete all command called");
			for (Integer i : selectedTasks.keySet()) {
				Task t = selectedTasks.get(i);
				logger.log(Level.INFO, "Removing every trace of " + t);
				deletedTasks.add((Task) t.clone());
				allSchedules.remove(t);
				allDeadlines.remove(t);
				allTodos.remove(t);
				requestedSchedules.remove(t);
				requestedDeadlines.remove(t);
				requestedTodos.remove(t);
			}

			logger.log(Level.INFO, "Preparing for file sync");
			fileSync();
			return DELETE_ALL;
		}

		logger.log(Level.INFO, "Preparing for file sync");
		fileSync();

		return String.format(DELETE_SUCCESSFUL, ac.getReferenceNumber());

	}

	private String deleteUndo() {
		logger.log(Level.INFO, "In delete undo function");
		System.out.println(deletedTasks);
		for (Task t : deletedTasks) {
			// uniqueId--;
			if (t instanceof Schedule) {
				logger.log(Level.INFO, "Recovering deleted schedule: " + t);
				allSchedules.add((Schedule) t);
			} else if (t instanceof Deadline) {
				logger.log(Level.INFO, "Recovering deleted deadline: " + t);
				allDeadlines.add((Deadline) t);
			} else if (t instanceof Todo) {
				logger.log(Level.INFO, "Recovering deleted todo: " + t);
				allTodos.add((Todo) t);
			}

			t.setLastModifiedDate(Calendar.getInstance());
			t.setRemoteId(null);
		}

		logger.log(Level.INFO, "Preparing for file sync");
		fileSync();

		return UNDO_DELETE_SUCCESSFUL;
	}

	private TaskType classifyUpdate(UpdateAction ac) {
		if (ac.getUpdatedStartTime() == null) {
			if (ac.getUpdatedEndTime() == null) {
				return TaskType.TODO;
			} else {
				return TaskType.DEADLINE;
			}
		} else {
			return TaskType.SCHEDULE;
		}

	}

	private String update(UpdateAction ac) {
		logger.log(Level.INFO, "In update function");
		ArrayList<Schedule> sc = new ArrayList<Schedule>();
		String output = String.format(UPDATE_SUCCESSFUL,
				ac.getReferenceNumber(), ac.getUpdatedQuery());
		System.out.println(ac);
		if (ac.getReferenceNumber() <= selectedTasks.size()
				&& ac.getReferenceNumber() > 0) {
			Task t = selectedTasks.get(ac.getReferenceNumber());
			if (t.getTaskType() != classifyUpdate(ac)) {
				return UPDATE_TYPE_CLASH;
			}

			if (t instanceof Schedule) {
				logger.log(Level.INFO, "Updating schedule: " + t);
				updateOriginalTask = (Schedule) t.clone();
				((Schedule) t).setStartTime(ac.getUpdatedStartTime());
				((Schedule) t).setEndTime(ac.getUpdatedEndTime());
				if (!(sc = checkForScheduleClashes((Schedule) t)).isEmpty()) {
					logger.log(Level.INFO, "Clashed schedules found");
					output += NEWLINE + UPDATE_WARNING_CLASH;
					for (Schedule s : sc) {
						output += s.outputStringForDisplay() + NEWLINE;
					}
				}
			} else if (t instanceof Deadline) {
				logger.log(Level.INFO, "Updating schedule: " + t);
				updateOriginalTask = (Deadline) t.clone();
				((Deadline) t).setEndTime(ac.getUpdatedEndTime());
			} else if (t instanceof Todo) {
				logger.log(Level.INFO, "Updating todo: " + t);
				updateOriginalTask = (Todo) t.clone();
			}

			// common attributes to all schedules deadlines and todos
			t.setPlace(ac.getUpdatedLocationQuery());
			t.setDescription(ac.getUpdatedQuery());
			t.setLastModifiedDate(Calendar.getInstance());

			fileSync();
			return output;
		}

		return INVALID_NUMBER_INPUT;
	}

	private String updateUndo() {
		logger.log(Level.INFO, "In update undo function");

		logger.log(Level.INFO, "undoing update back to task:  "
				+ updateOriginalTask);
		
		Schedule scheduleToRemove = null;
		Schedule scheduleToAdd = null;
		for (Schedule s : allSchedules) {
			if (s.getUniqueId() == updateOriginalTask.getUniqueId()) {
				scheduleToRemove = s;
				scheduleToAdd = (Schedule) updateOriginalTask.clone();
				break;
			}
		}
		if(scheduleToRemove != null) {
			allSchedules.remove(scheduleToRemove);

			scheduleToAdd.setLastModifiedDate(Calendar.getInstance());
			allSchedules.add(scheduleToAdd);
		}
		
		Deadline deadlineToRemove = null;
		Deadline deadlineToAdd = null;
		for (Deadline d : allDeadlines) {
			if (d.getUniqueId() == updateOriginalTask.getUniqueId()) {
				deadlineToRemove = d;
				deadlineToAdd = (Deadline) updateOriginalTask.clone();
				break;
			}
		}
		if(deadlineToRemove != null) {
			allDeadlines.remove(deadlineToRemove);

			deadlineToAdd.setLastModifiedDate(Calendar.getInstance());
			allDeadlines.add(deadlineToAdd);
		}
		
		Todo todoToRemove = null;
		Todo todoToAdd = null;
		for (Todo td : allTodos) {
			if (td.getUniqueId() == updateOriginalTask.getUniqueId()) {
				todoToRemove = td;
				todoToAdd = (Todo) updateOriginalTask.clone();
				break;
			}
		}
		if(todoToRemove != null) {
			allTodos.remove(todoToRemove);

			todoToAdd.setLastModifiedDate(Calendar.getInstance());
			allTodos.add(todoToAdd);
		}

		fileSync();
		updateOriginalTask = null;

		return UNDO_UPDATE_SUCCESSFUL;
	}

	private String search(SearchAction ac) {
		logger.log(Level.INFO,
				"In search function. Clearing all previously requested tasks from memory");
		requestedSchedules.clear();
		requestedDeadlines.clear();
		requestedTodos.clear();
		selectedTasks.clear();

		String output = EMPTY_STRING;

		for (Schedule s : allSchedules) {
			if (((s.getDescription()).toLowerCase()).contains((ac.getQuery()
					.toLowerCase()))) {
				if ((s.getStartTime().after(ac.getStartTime()) && s
						.getEndTime().before(ac.getEndTime()))
						|| (s.getStartTime().compareTo(ac.getStartTime()) == 0 || (s
								.getEndTime().compareTo(ac.getEndTime()) == 0))) {
					logger.log(Level.INFO, "Found schedule match");
					requestedSchedules.add(s);
				}
			}
		}

		for (Deadline d : allDeadlines) {
			if (((d.getDescription()).toLowerCase()).contains((ac.getQuery()
					.toLowerCase()))) {
				if ((d.getEndTime().after(ac.getStartTime()) && d
						.getEndTime().before(ac.getEndTime()))
						|| (d.getEndTime().compareTo(ac.getStartTime()) == 0)
						|| (d.getEndTime().compareTo(ac.getEndTime()) == 0)) {
					logger.log(Level.INFO, "Found deadline match");
					requestedDeadlines.add(d);
				}
			}
		}

		for (Todo td : allTodos) {
			if (((td.getDescription()).toLowerCase()).contains((ac.getQuery()
					.toLowerCase()))) {
				logger.log(Level.INFO, "Found todo match");
				requestedTodos.add(td);
			}
		}

		output = SEARCH_PREFIX;

		if (requestedTodos.isEmpty() && requestedDeadlines.isEmpty()
				&& requestedSchedules.isEmpty()) {
			logger.log(Level.INFO, "No search matches found");
			output = output + SEARCH_UNFOUND;
		}

		return displayOutput(output);
	}

	private String mark(MarkAction ac) {
		logger.log(Level.INFO, "In mark function");
		String numbers = EMPTY_STRING;
		markUndoList = new ArrayList<Task>();

		if (checkValidReferenceNumbers(ac.getReferenceNumber())) {
			for (Integer num : ac.getReferenceNumber()) {

				logger.log(Level.INFO, "Number input within range");
				Task t = selectedTasks.get(num);
				markUndoList.add((Task) t.clone());
				numbers = numbers + num + BLANK_SPACE;

				if (t instanceof Deadline) {
					logger.log(Level.INFO,
							"Marking deadline as " + ac.getStatus());
					((Deadline) t).setStatus(ac.getStatus());
				} else if (t instanceof Todo) {
					logger.log(Level.INFO, "Marking todo as " + ac.getStatus());
					((Todo) t).setStatus(ac.getStatus());
				} else {
					logger.log(Level.INFO,
							"User trying to mark schedule. Returning error");
					return MARK_SCHEDULE_ERROR;
				}

				t.setLastModifiedDate(Calendar.getInstance());
			}
		} else {
			logger.log(Level.INFO, "Number input out of range. Returning error");
			return INVALID_NUMBER_INPUT;
		}

		logger.log(Level.INFO, "Preparing for file sync");
		fileSync();

		return String.format(MARK_SUCCESSFUL, numbers, ac.getStatus());
	}

	private String markUndo() {
		logger.log(Level.INFO, "In mark undo function");

		for (Task t : markUndoList) {
			for (Deadline d : allDeadlines) {
				if (d.getUniqueId() == t.getUniqueId()) {
					logger.log(Level.INFO, "undoing status of deadline: " + d);
					d.setStatus(((Deadline) t).getStatus());
				}
			}
			for (Todo td : allTodos) {
				if (td.getUniqueId() == t.getUniqueId()) {
					logger.log(Level.INFO, "undoing status of todo: " + td);
					td.setStatus(((Todo) t).getStatus());
				}
			}
			t.setLastModifiedDate(Calendar.getInstance());
		}

		logger.log(Level.INFO, "Preparing for file sync");
		fileSync();

		return UNDO_MARK_SUCCESSFUL;
	}

	private void fileSync() {
		BufferedWriter clearWriter = null;
		BufferedWriter appendWriter = null;
		try {
			clearWriter = new BufferedWriter(new FileWriter(file));
			logger.log(Level.INFO, "Clearing file");
			clearWriter.write(EMPTY_STRING);
			appendWriter = new BufferedWriter(new FileWriter(file, true));

			for (Schedule s : allSchedules) {
				logger.log(Level.INFO, "Appending schedule " + s);
				appendWriter.write(s.toString());
				appendWriter.newLine();
			}

			for (Deadline d : allDeadlines) {
				logger.log(Level.INFO, "Appending deadline " + d);
				appendWriter.write(d.toString());
				appendWriter.newLine();
			}

			for (Todo td : allTodos) {
				logger.log(Level.INFO, "Appending td " + td);
				appendWriter.write(td.toString());
				appendWriter.newLine();
			}

		} catch (IOException e) {
			logger.log(Level.WARNING, "Error detected" + e.getMessage());
			e.printStackTrace();
		} finally {
			logger.log(Level.INFO, "Closing buffered writers");
			try {
				clearWriter.close();
				appendWriter.close();
			} catch (IOException e) {
				logger.log(
						Level.WARNING,
						"Unable to close buffered writers due to error: "
								+ e.getMessage());
			}
		}
	}

	private Task findTaskFromUniqueId(int uniqueId)
			throws TaskNotFoundException {
		logger.log(Level.INFO, "In find task from unique id function");
		for (Schedule s : allSchedules) {
			if (s.getUniqueId() == uniqueId) {
				logger.log(Level.INFO, "Task found is a schedule" + s);
				return s;
			}
		}
		for (Deadline d : allDeadlines) {
			if (d.getUniqueId() == uniqueId) {
				logger.log(Level.INFO, "Task found is a deadline" + d);
				return d;
			}
		}
		for (Todo td : allTodos) {
			if (td.getUniqueId() == uniqueId) {
				logger.log(Level.INFO, "Task found is a todo" + td);
				return td;
			}
		}

		logger.log(Level.WARNING, "Task is not found");
		throw new TaskNotFoundException("Task not found");
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\TasksManager.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\TasksManager.java
	 */

	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\TasksManager.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\TaskType.java
	 */

package com.licensetokil.atypistcalendar.tasksmanager;

public enum TaskType {
	SCHEDULE("schedule"),
	DEADLINE("deadline"),
	TODO("todo");
	
	private final String strTaskType;
	
	private TaskType(String newStrTaskType){
		strTaskType = newStrTaskType;
	}
	
	public String toString(){
		return strTaskType;
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\TaskType.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\TaskType.java
	 */

	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\TaskType.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\Todo.java
	 */

package com.licensetokil.atypistcalendar.tasksmanager;

import java.util.Calendar;

public class Todo extends Task implements Comparable<Todo>, Cloneable {
	private static final String OUTPUT_FORMAT = "[Status: %s] %s";
	private String remoteId;
	private TaskType taskType;
	private int uniqueId;
	private Calendar lastModifiedDate;
	private String description;
	private String place;
	private String status;

	public Todo(int uniqueId, String description, String place, String status,
			Calendar lastModifiedDate) {
		this.uniqueId = uniqueId;
		this.taskType = TaskType.TODO;
		this.description = description;
		this.place = place;
		this.status = status;
		this.lastModifiedDate = lastModifiedDate;
	}

	public Todo() {
	}

	public String getRemoteId() {
		return remoteId;
	}

	public int getUniqueId() {
		return uniqueId;
	}

	public TaskType getTaskType() {
		return taskType;
	}

	public Calendar getLastModifiedDate() {
		return lastModifiedDate;
	}

	public String getDescription() {
		return description;
	}

	public String getPlace() {
		return place;
	}

	public String getStatus() {
		return status;
	}

	public void setDescription(String d) {
		this.description = d;
	}

	public void setPlace(String p) {
		this.place = p;
	}

	public void setStatus(String s) {
		this.status = s;
	}

	public void setRemoteId(String remoteId) {
		this.remoteId = remoteId;
	}

	public void setLastModifiedDate(Calendar lastModifiedDate) {
		this.lastModifiedDate = lastModifiedDate;
	}

	public void setTaskType(TaskType t) {
		this.taskType = t;
	}

	public void setUniqueId(int uniqueId) {
		this.uniqueId = uniqueId;
	}

	public String toString() {
		if (place.equals(EMPTY_STRING)) {
			return TaskType.TODO + DELIMITER + uniqueId + DELIMITER
					+ description + DELIMITER + BLANK_SPACE + DELIMITER
					+ status + DELIMITER + lastModifiedDate.getTime()
					+ DELIMITER + remoteId;
		}
		return TaskType.TODO + DELIMITER + uniqueId + DELIMITER + description
				+ DELIMITER + place + DELIMITER + status + DELIMITER
				+ lastModifiedDate.getTime() + DELIMITER + remoteId;
	}

	public String outputStringForDisplay() {
		String stringStatus = status;
		if (stringStatus.equals(DONE_NO_ALIGN)) {
			stringStatus = DONE_ALIGN;
		}

		String output = String.format(OUTPUT_FORMAT, stringStatus, description);
		if (!place.equals(EMPTY_STRING)) {
			output = String.format(DISPLAY_PLACE_NOT_EMPTY, output,
					this.getPlace());
		}

		return output;
	}

	public int compareTo(Todo td) {
		return description.compareTo(td.getDescription());
	}

	@Override
	public Object clone() {
		Todo clonedObject = new Todo();
		clonedObject.remoteId = this.remoteId;
		clonedObject.taskType = this.taskType;
		clonedObject.uniqueId = this.uniqueId;
		clonedObject.description = this.description;
		clonedObject.place = this.place;
		clonedObject.status = this.status;
		clonedObject.lastModifiedDate = (Calendar) this.lastModifiedDate
				.clone();

		return clonedObject;
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\Todo.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\tasksmanager\Todo.java
	 */


	// End of segment: src\com\licensetokil\atypistcalendar\tasksmanager\Todo.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\ui\ATCGUI.java
	 */

package com.licensetokil.atypistcalendar.ui;

import java.awt.Font;
import java.awt.Image;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.io.StringReader;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.GroupLayout;
import javax.swing.ImageIcon;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.UIManager;
import javax.swing.text.html.HTMLEditorKit;

import com.licensetokil.atypistcalendar.ATypistCalendar;

public class ATCGUI extends JFrame implements WindowListener {

	private static final long serialVersionUID = 1L;
	private final static String MESSAGE_WELCOME = "Welcome to a Typist's Calendar!\n";
	private final static String MESSAGE_WELCOME_FORMAT = "<b>%s</b><br><hr>";
	private final static String MESSAGE_TITLE = "A Typist's Calendar";
	private final static String MESSAGE_COMMAND = "Type your command here:";

	private final static String KEY_DOWN = "DOWN";
	private final static String KEY_UP = "UP";
	private final static String POSITIVE_UNIT_INCREMENT = "positiveUnitIncrement";
	private final static String NEGATIVE_UNIT_INCREMENT = "negativeUnitIncrement";
	private final static String EMPTY_STRING = "";

	private final static String NEWLINE_REGEX = "\\r|\\n";
	private final static String NEWLINE_HTML = "<br>";

	private final static String OUTPUT_FORMAT = "%s<hr><br>";

	private final static int FONT_SIZE = 14;
	private final static int EDITOR_SCROLLPANE_FONT_SIZE = 18;
	private final static int FONT_STYLE = 0;
	private final static int BACKGROUND_COLOR_RGB = 222;
	private final static int TEXTAREA_FONT_SIZE = 12;
	private final static int TEXTAREA_FONT_STYLE = 1;
	private final static int TEXTAREA_COLUMNS = 20;
	private final static int TEXTAREA_ROWS = 5;
	private final static int SCROLLPANE_WIDTH = 700;
	private final static int SCROLLPANE_HEIGHT = 402;
	private final static int GAP1 = 0;
	private final static int GAP2 = 5;
	private final static int TEXTFIELD_SIZE = 33;
	private final static int AREASCROLLPANE_SIZE = 29;

	private final static String DEFAULT_ICON_RESOURCE_PATH = "/icon128.png";
	private final static String SYNCING_ICON_RESOURCE_PATH = "/icon128sync.png";

	private static Logger logger = Logger.getLogger("ATCGUI");

	private Image defaultIcon;
	private Image syncingIcon;

	//public constructor
	public ATCGUI() {
		try {
			logger.log(Level.INFO, "Set to cross-platform Nimbus Look and Feel");
			UIManager
					.setLookAndFeel("javax.swing.plaf.nimbus.NimbusLookAndFeel");
		} catch (Exception e) {
			logger.log(Level.WARNING, "Error detected: " + e.getMessage());
		}

		getResources();
		initComponents();
		this.setContentPane(jPanel);
		addWindowListener(this);
	}

	// function that displays responses from user input
	public void outputWithNewline(String text) {
		logger.log(Level.INFO, "In outputWithNewline function");
		StringReader reader;

		if (text.contains(MESSAGE_WELCOME)) {
			logger.log(Level.INFO, "Displaying Welcome Message");
			text = text.replaceAll(NEWLINE_REGEX, NEWLINE_HTML);
			jEditorPane.setText(String.format(MESSAGE_WELCOME_FORMAT, text));
		}

		else {
			logger.log(Level.INFO, "Displaying all other output");
			text = text.replaceAll(NEWLINE_REGEX, NEWLINE_HTML);
			reader = new StringReader(String.format(OUTPUT_FORMAT, text));
			try {
				htmlEditorKit.read(reader, jEditorPane.getDocument(),
						jEditorPane.getDocument().getLength());
			} catch (Exception e) {
				logger.log(Level.WARNING, "Error detected: " + e.getMessage());
			}
		}

		jEditorPane.setCaretPosition(jEditorPane.getDocument().getLength());
		jTextField.requestFocus();
	}

	//for window closing
	public void dispatchWindowClosingEvent() {
		logger.log(Level.INFO, "In dispatchWindowClosingEventFunction");
		dispatchEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));
	}

	//function to output the previous user input for convenience purposes
	public void outputUserInput(String input) {
		logger.log(Level.INFO, "In outputUserInput function");
		jTextArea.setText(input);
	}

	public void changeWindowIcon(boolean useSyncingIcon) {
		logger.log(Level.INFO, "Changing window icon");

		if(useSyncingIcon) {
			logger.log(Level.INFO, "Using syncing icon");
			setIconImage(syncingIcon);
		}
		else {
			logger.log(Level.INFO, "Using default icon");
			setIconImage(defaultIcon);
		}
	}

	@Override
	//function to save data into files when window is closed
	public void windowClosing(WindowEvent e) {
		logger.log(Level.INFO, "In windowClosing function");
		ATypistCalendar.getInstance().cleanUp();
	}

	@Override
	public void windowOpened(WindowEvent e) {
	}

	@Override
	public void windowClosed(WindowEvent e) {
	}

	@Override
	public void windowIconified(WindowEvent e) {
	}

	@Override
	public void windowDeiconified(WindowEvent e) {
	}

	@Override
	public void windowActivated(WindowEvent e) {
	}

	@Override
	public void windowDeactivated(WindowEvent e) {
	}

	private void getResources() {
		logger.log(Level.INFO, "Getting resources");

		defaultIcon = (new ImageIcon(getClass().getResource(DEFAULT_ICON_RESOURCE_PATH))).getImage();
		syncingIcon = (new ImageIcon(getClass().getResource(SYNCING_ICON_RESOURCE_PATH))).getImage();
	}

	//initialising function
	private void initComponents() {

		logger.log(Level.INFO, "Initialising various components of GUI");
		jPanel = new JPanel();
		jTextField = new JTextField();
		jLabel = new JLabel();
		editorScrollPane = new JScrollPane();
		jEditorPane = new JEditorPane("text/html", null);
		areaScrollPane = new JScrollPane();
		jTextArea = new JTextArea();
		htmlEditorKit = new HTMLEditorKit();

		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		setTitle(MESSAGE_TITLE);
		setIconImage(new ImageIcon(getClass().getResource("/icon128.png"))
				.getImage());

		jTextField.addKeyListener(new java.awt.event.KeyAdapter() {
			public void keyReleased(java.awt.event.KeyEvent evt) {
				jTextField1KeyReleased(evt);
			}
		});

		setKeyScrolling();

		logger.log(Level.INFO, "Configuring jLabel");
		jLabel.setFont(new java.awt.Font("Consolas", FONT_STYLE, FONT_SIZE));
		jLabel.setText(MESSAGE_COMMAND);

		logger.log(Level.INFO, "Configuring editorScrollPane");
		editorScrollPane.setBorder(javax.swing.BorderFactory
				.createTitledBorder(null, MESSAGE_TITLE,
						javax.swing.border.TitledBorder.CENTER,
						javax.swing.border.TitledBorder.DEFAULT_POSITION,
						new java.awt.Font("Consolas", FONT_STYLE, EDITOR_SCROLLPANE_FONT_SIZE)));
		editorScrollPane.setMaximumSize(jPanel.getMaximumSize());
		editorScrollPane.setMinimumSize(jPanel.getMinimumSize());
		editorScrollPane.setViewportView(jEditorPane);

		logger.log(Level.INFO, "Configuring areaScrollPane");
		areaScrollPane.setBorder(null);
		areaScrollPane
				.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
		areaScrollPane.setAutoscrolls(true);

		logger.log(Level.INFO, "Configuring editorPane");
		jEditorPane.setFont(new Font("Consolas", Font.PLAIN, FONT_SIZE));
		jEditorPane.setEditorKit(htmlEditorKit);
		jEditorPane.setEditable(false);

		logger.log(Level.INFO, "Configuring textArea");
		jTextArea.setEditable(false);
		jTextArea.setBackground(new java.awt.Color(BACKGROUND_COLOR_RGB, BACKGROUND_COLOR_RGB, BACKGROUND_COLOR_RGB));
		jTextArea.setColumns(TEXTAREA_COLUMNS);
		jTextArea.setFont(new java.awt.Font("Consolas", TEXTAREA_FONT_STYLE, TEXTAREA_FONT_SIZE));
		jTextArea.setRows(TEXTAREA_ROWS);
		jTextArea.setBorder(null);
		areaScrollPane.setViewportView(jTextArea);

		logger.log(Level.INFO, "Configuring various layout and outlook");
		GroupLayout jPanel1Layout = new GroupLayout(jPanel);
		jPanel.setLayout(jPanel1Layout);
		jPanel1Layout
				.setHorizontalGroup(jPanel1Layout
						.createParallelGroup(GroupLayout.Alignment.LEADING)
						.addGroup(
								jPanel1Layout
										.createSequentialGroup()
										.addContainerGap()
										.addGroup(
												jPanel1Layout
														.createParallelGroup(
																GroupLayout.Alignment.LEADING)
														.addComponent(
																editorScrollPane,
																GroupLayout.DEFAULT_SIZE,
																SCROLLPANE_WIDTH,
																Short.MAX_VALUE)
														.addComponent(
																jTextField)
														.addGroup(
																jPanel1Layout
																		.createSequentialGroup()
																		.addComponent(
																				jLabel)
																		.addGap(GAP1,
																				GAP1,
																				Short.MAX_VALUE))
														.addComponent(
																areaScrollPane))
										.addContainerGap()));
		jPanel1Layout
				.setVerticalGroup(jPanel1Layout
						.createParallelGroup(GroupLayout.Alignment.LEADING)
						.addGroup(
								jPanel1Layout
										.createSequentialGroup()
										.addContainerGap()
										.addComponent(editorScrollPane,
												GroupLayout.PREFERRED_SIZE,
												SCROLLPANE_HEIGHT, Short.MAX_VALUE)
										.addPreferredGap(
												javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
										.addComponent(jLabel)
										.addPreferredGap(
												javax.swing.LayoutStyle.ComponentPlacement.RELATED)
										.addComponent(jTextField,
												GroupLayout.PREFERRED_SIZE, TEXTFIELD_SIZE,
												GroupLayout.PREFERRED_SIZE)
										.addPreferredGap(
												javax.swing.LayoutStyle.ComponentPlacement.RELATED)
										.addComponent(areaScrollPane,
												GroupLayout.PREFERRED_SIZE, AREASCROLLPANE_SIZE,
												GroupLayout.PREFERRED_SIZE)
										.addGap(GAP2, GAP2, GAP2)));

		GroupLayout layout = new GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				GroupLayout.Alignment.LEADING).addComponent(jPanel,
				GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE,
				Short.MAX_VALUE));
		layout.setVerticalGroup(layout.createParallelGroup(
				GroupLayout.Alignment.LEADING).addComponent(jPanel,
				GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,
				GroupLayout.PREFERRED_SIZE));

		pack();
	}

	// Function for attaching up and down keys to up and down scrolling of
	// editor pane
	private void setKeyScrolling() {
		logger.log(Level.INFO, "Setting key scrolling with editorPane");
		JScrollBar scrollBar = editorScrollPane.getVerticalScrollBar();
		InputMap inputMap = scrollBar
				.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
		inputMap.put(KeyStroke.getKeyStroke(KEY_DOWN), POSITIVE_UNIT_INCREMENT);
		inputMap.put(KeyStroke.getKeyStroke(KEY_UP), NEGATIVE_UNIT_INCREMENT);
	}

	// function to respond to an enter key in jtextfield
	private void jTextField1KeyReleased(java.awt.event.KeyEvent evt) {
		if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER) {
			if (jTextField.getText().equals(EMPTY_STRING)) {
				logger.log(Level.INFO, "No input detected. Returning");
				return;
			}
			logger.log(Level.INFO,
					"Getting user input. Setting text field to empty");
			ATypistCalendar.getInstance().userInput(jTextField.getText());
			jTextField.setText(EMPTY_STRING);
		}
	}

	// Variables declaration
		private JLabel jLabel;
		private JPanel jPanel;
		private JScrollPane editorScrollPane;
		private JScrollPane areaScrollPane;
		private JTextArea jTextArea;
		private JTextField jTextField;
		private JEditorPane jEditorPane;
		private HTMLEditorKit htmlEditorKit;

}
	// End of segment: src\com\licensetokil\atypistcalendar\ui\ATCGUI.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\ui\ATCGUI.java
	 */


	// End of segment: src\com\licensetokil\atypistcalendar\ui\ATCGUI.java





