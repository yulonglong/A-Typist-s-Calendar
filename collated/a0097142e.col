//@author: a0097142e



	/**
	 * origin: src\com\licensetokil\atypistcalendar\ATypistCalendar.java
	 */

package com.licensetokil.atypistcalendar;

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Logger;

import javax.swing.JDialog;
import javax.swing.JOptionPane;

import com.licensetokil.atypistcalendar.gcal.GoogleCalendarManager;
import com.licensetokil.atypistcalendar.parser.Action;
import com.licensetokil.atypistcalendar.parser.DisplayAction;
import com.licensetokil.atypistcalendar.parser.ExitAction;
import com.licensetokil.atypistcalendar.parser.GoogleAction;
import com.licensetokil.atypistcalendar.parser.LocalAction;
import com.licensetokil.atypistcalendar.parser.MalformedUserInputException;
import com.licensetokil.atypistcalendar.parser.Parser;
import com.licensetokil.atypistcalendar.parser.SearchAction;
import com.licensetokil.atypistcalendar.parser.SystemAction;
import com.licensetokil.atypistcalendar.tasksmanager.Task;
import com.licensetokil.atypistcalendar.tasksmanager.TaskNotFoundException;
import com.licensetokil.atypistcalendar.tasksmanager.TasksManager;
import com.licensetokil.atypistcalendar.ui.ATCGUI;

public class ATypistCalendar {
	private static final String EMPTY_STRING = "";

	private static final String ERROR_DIALOG_TITLE = "Fatal Error";
	private static final String ERROR_DIALOG_MESSAGE = "A Typist's Calendar is unable to load the SWT library that is required for running. Exiting...";

	private static final String RESOURCE_PATH_SWT_X64_JAR = "/swt_x64.jar";
	private static final String RESOURCE_PATH_SWT_X86_JAR = "/swt_x86.jar";

	private static final String JAVA_VM_NAME = "java.vm.name";
	private static final String JAVA_VM_NAME_KEYWORD_64_BIT = "64-Bit";

	private static final String PROGRAM_ARGUMENT_LOG_TO_FILE = "-logToFile";

	private static final String ATC_ERROR_STREAM_LOG_FILE_NAME = "atc_errorStream.log";

	private static final String MESSAGE_USER_INPUT_FEEDBACK_UPON_SUCCESSFUL_COMMAND = "Your previous command: %s";
	private static final String MESSAGE_USER_INPUT_FEEDBACK_UPON_FAILED_COMMAND = "Your previous (erroneous) command: %s";

	private static ATypistCalendar instance = null;

	@SuppressWarnings("unused")
	private static Logger masterLogger = Logger.getLogger(ATypistCalendar.class.getPackage().getName());
	private static Logger logger = Logger.getLogger(ATypistCalendar.class.getName());

	private ATCGUI gui;

	private ATypistCalendar() {
	}

	public static ATypistCalendar getInstance() {
		if(instance == null) {
			instance = new ATypistCalendar();
		}
		return instance;
	}

	public static void main(String[] args) {
		//No logging allowed until we set the System.err stream (if needed)
		//Logging before setting the stream will make the logging system hook on the original System.err stream.
		if(containsStringIgnoreCase(args, PROGRAM_ARGUMENT_LOG_TO_FILE)) {
			redirectSystemErrorStream();
		}

		ATypistCalendar.getInstance().initialize(args);
	}

	private static boolean containsStringIgnoreCase(String[] args, String string) {
		if(args.length == 0) {
			return false;
		}

		for(String element : args) {
			if(element.equalsIgnoreCase(string)) {
				return true;
			}
		}

		return false;
	}

	private static void redirectSystemErrorStream() {
		try {
			PrintStream errStream = new PrintStream(ATC_ERROR_STREAM_LOG_FILE_NAME);
			System.setErr(errStream);

			//We can start logging from here onwards.
			logger.info("Successfully redirected System.err to file.");
		} catch (FileNotFoundException e) {
			logger.severe("Unable to redirect System.err to file! Continuing with default System.err. (Quiet failure)");
			e.printStackTrace();
		}
	}

	private void initialize(String[] args) {
		logger.fine("initialize called.");

		logger.info("Loading SWT library.");
		loadSwtLibrary();

		logger.info("Creating new GUI instance.");
		gui = new ATCGUI();
		gui.setVisible(true);

		logger.info("Greeting the user.");
		Calendar calendar = Calendar.getInstance();
		gui.outputWithNewline("Welcome to a Typist Calendar!\n\nCurrent time:\n" + calendar.getTime().toString());

		logger.info("Initializing modules.");
		TasksManager.getInstance().initialize();
		GoogleCalendarManager.getInstance().initialize();

		logger.info("Initiallizing done.");
	}

	private void loadSwtLibrary() {
		logger.fine("loadSwtLibrary called.");

		logger.info("Deciding which version (32- or 64-bit) of the SWT library to include.");
		URL pathToSWT;
		if(System.getProperty(JAVA_VM_NAME).contains(JAVA_VM_NAME_KEYWORD_64_BIT)) {
			logger.info("Finding path to 64-bit SWT library.");
			pathToSWT = getClass().getResource(RESOURCE_PATH_SWT_X64_JAR);
			logger.info("Path to 64-bit SWT library found.");
		}
		else {
			logger.info("Finding path to 32-bit SWT library.");
			pathToSWT = getClass().getResource(RESOURCE_PATH_SWT_X86_JAR);
			logger.info("Path to 32-bit SWT library found.");
		}

		try {
			logger.info("Reflecting the URLClassLoader.addURL method to expose it (protected -> public)");
			Method method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
			method.setAccessible(true);

			logger.info("Invoking the URLClassLoader.addURL method of the ATypistCalendar class'es ClassLoader.");
			method.invoke((URLClassLoader)ATypistCalendar.class.getClassLoader(), pathToSWT);
		}
		catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			logger.severe("Unable to load the SWT library! Displaying error message and exiting.");
			e.printStackTrace();
			JOptionPane.showMessageDialog(new JDialog(), ERROR_DIALOG_MESSAGE, ERROR_DIALOG_TITLE, JOptionPane.ERROR_MESSAGE);
			System.exit(1);
		}
		logger.info("SWT library loaded successful.");
	}



	public void userInput(String input) {
		String reply = EMPTY_STRING;
		Action action;
		try {
			action = Parser.parse(input);
		} catch (MalformedUserInputException muie) {
			gui.outputUserInput(String.format(MESSAGE_USER_INPUT_FEEDBACK_UPON_FAILED_COMMAND, input));
			gui.outputWithNewline(muie.getMessage());
			return;
		}

		if(action instanceof LocalAction) {
			reply = TasksManager.getInstance().executeCommand((LocalAction)action);
			if(!(action instanceof DisplayAction || action instanceof SearchAction)) {
				GoogleCalendarManager.getInstance().doCompleteSync();
			}
		}
		else if(action instanceof GoogleAction) {
			reply = GoogleCalendarManager.getInstance().executeCommand((GoogleAction)action);
		}
		else if(action instanceof SystemAction) {
			reply = executeCommand((SystemAction)action);
		}
		else {
			logger.severe("Unknown sub-class of Action returned from Parser!");
			assert false;
		}

		gui.outputUserInput(String.format(MESSAGE_USER_INPUT_FEEDBACK_UPON_SUCCESSFUL_COMMAND, input));
		gui.outputWithNewline(reply);
	}

	public void cleanUp() {
		TasksManager.getInstance().exit();
	}

	public ArrayList<Task> getCopyOfAllLocalTasks() {
		return TasksManager.getInstance().cloneAllTasks();
	}

	public void updateLocalTaskWithCorrespondingTaskRemoteId(int localTaskId, String remoteTaskId) {
		try {
			TasksManager.getInstance().updateCorrespondingTaskRemoteId(localTaskId, remoteTaskId);
		} catch (TaskNotFoundException e) {
			logger.warning("Local task not found. Nothing to do - discrepancies will be handle by next sync.");
		}
	}

	public void updateTasksManagerWithUpdatedLocalTask(Task updatedLocalTask) {
		try {
			TasksManager.getInstance().updateGoogleTask(updatedLocalTask);
		} catch (TaskNotFoundException e) {
			logger.warning("Local task could not found. Nothing to do - discrepancies will be handle by next sync.");
		}
	}

	public void deleteLocalTaskfromTasksManager(int localTaskId) {
		try {
			TasksManager.getInstance().deleteGoogleTask(localTaskId);
		} catch (TaskNotFoundException e) {
			logger.warning("Local task could not found. Nothing to do - discrepancies will be handle by next sync.");
		}
	}

	public Task insertLocalTaskIntoTasksManager(String description, String location, Calendar lastModifiedDate, String remoteTaskId) {
		return TasksManager.getInstance().addTodoFromGoogle(description, location, lastModifiedDate, remoteTaskId);
	}

	public Task insertLocalTaskIntoTasksManager(String description, String location, Calendar lastModifiedDate, String remoteTaskId, Calendar endTime) {
		return TasksManager.getInstance().addDeadlineFromGoogle(endTime, description, location, lastModifiedDate, remoteTaskId);
	}

	public Task insertLocalTaskIntoTasksManager(String description, String location, Calendar lastModifiedDate, String remoteTaskId, Calendar endTime, Calendar startTime) {
		return TasksManager.getInstance().addScheduleFromGoogle(startTime, endTime, description, location, lastModifiedDate, remoteTaskId);
	}

	public void setSyncerStatus(boolean syncerIsExecuting) {
		gui.changeWindowIcon(syncerIsExecuting);
	}

	private String executeCommand(SystemAction action) {
		if(action instanceof ExitAction) {
			gui.dispatchWindowClosingEvent();
			return EMPTY_STRING;
		}
		else {
			logger.severe("Unknown sub-class of SystemAction!");
			assert false;
			return EMPTY_STRING;
		}
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\ATypistCalendar.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\AddSyncNode.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import com.licensetokil.atypistcalendar.tasksmanager.Task;

public class AddSyncNode extends SyncNode {
	private Task localTask;

	public AddSyncNode(Task localTask) {
		super();
		setLocalTask(localTask);
	}

	public Task getLocalTask() {
		return localTask;
	}

	public void setLocalTask(Task localTask) {
		this.localTask = localTask;
	}

	protected int getPriority() {
		return SyncNode.PRIORITY_MEDIUM;
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\AddSyncNode.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\AuthenticationDialog.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import java.awt.Dialog;

import javax.swing.JDialog;
import javax.swing.SwingUtilities;

import chrriis.dj.nativeswing.NSOption;
import chrriis.dj.nativeswing.swtimpl.NativeInterface;
import chrriis.dj.nativeswing.swtimpl.components.JWebBrowser;
import chrriis.dj.nativeswing.swtimpl.components.WebBrowserAdapter;
import chrriis.dj.nativeswing.swtimpl.components.WebBrowserNavigationEvent;

class AuthenticationDialog extends JDialog {
	private static final boolean AUTHENTICATION_DIALOG_WEB_BROWSER_BARS_VISIBILITY = false;
	private static final String AUTHENTICATION_DIALOG_TITLE = "Google Calendar Authentication";
	private static final int AUTHENTICATION_DIALOG_WIDTH = 800;
	private static final int AUTHENTICATION_DIALOG_HEIGHT = 600;

	private static final String AUTHENICATION_URL = "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=" +
			AuthenticationManager.GOOGLE_API_CLIENT_ID +
			"&redirect_uri=urn:ietf:wg:oauth:2.0:oob&scope=https://www.googleapis.com/auth/calendar";

	private static final String REPLY_TARGET_URL = "https://accounts.google.com/o/oauth2/approval";
	private static final String REPLY_SUCCESSFUL_AUTHENTICATION_LABEL = "Success code";
	private static final String REPLY_DELIMITER = "=";
	private static final int REPLY_LABEL_INDEX = 0;
	private static final int REPLY_VALUE_INDEX = 1;

	private static final long serialVersionUID = 1L;

	private JWebBrowser webBrowser;

	protected AuthenticationDialog() {
		webBrowser = new JWebBrowser(new NSOption(null));
		webBrowser.setBarsVisible(AUTHENTICATION_DIALOG_WEB_BROWSER_BARS_VISIBILITY);

		webBrowser.addWebBrowserListener(new WebBrowserAdapter() {
			public void locationChanged(WebBrowserNavigationEvent event) {
				webBrowserLocationChanged(event);
			}
		});

		this.setModalityType(Dialog.ModalityType.APPLICATION_MODAL);
		this.setTitle(AUTHENTICATION_DIALOG_TITLE);
		this.setSize(AUTHENTICATION_DIALOG_WIDTH, AUTHENTICATION_DIALOG_HEIGHT);
		this.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
		this.add(webBrowser);

		this.navigateToURL(AUTHENICATION_URL);

		this.setVisible(true);
	}

	private void navigateToURL(final String target) {
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				webBrowser.navigate(target);
			}
		});
	}

	private void webBrowserLocationChanged(WebBrowserNavigationEvent event) {
		boolean webBrowserIsAtTargetUrl = webBrowser.getResourceLocation().contains(REPLY_TARGET_URL);
		if (webBrowserIsAtTargetUrl) {
			String[] googleReplyDelimited = webBrowser.getPageTitle().split(REPLY_DELIMITER);
			boolean replyLabelledAsSuccessful =
					googleReplyDelimited[REPLY_LABEL_INDEX].equals(REPLY_SUCCESSFUL_AUTHENTICATION_LABEL);
			if (replyLabelledAsSuccessful) {
				AuthenticationManager.getInstance().authenticateUserSuccess(googleReplyDelimited[REPLY_VALUE_INDEX]);
			} else {
				AuthenticationManager.getInstance().authenticateUserFailed();
			}
			NativeInterface.close();
			this.dispose();
		}
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\gcal\AuthenticationDialog.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\AuthenticationManager.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Date;
import java.util.HashMap;

import chrriis.dj.nativeswing.swtimpl.NativeInterface;

import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

class AuthenticationManager {
	protected static final String GOOGLE_API_CLIENT_ID = "896350900683.apps.googleusercontent.com";
	protected static final String GOOGLE_API_CLIENT_SECRET = "MvKdYK7Ec74rMesvRvVfVdDF";

	private static final String AUTHORIZATION_HEADER_VALUE_PREFIX = "Bearer ";
	private static final String AUTHORIZATION_HEADER_LABEL = "Authorization";

	private static final String NULL_TOKEN = "";

	private static final String GOOGLE_REQUEST_URL_FETCH_ACCESS_TOKEN = "https://accounts.google.com/o/oauth2/token";

	private static final String FETCH_ACCESS_TOKEN_REQUEST_LABEL_CODE = "code";
	private static final String FETCH_ACCESS_TOKEN_REQUEST_LABEL_CLIENT_ID = "client_id";
	private static final String FETCH_ACCESS_TOKEN_REQUEST_LABEL_CLIENT_SECRET = "client_secret";
	private static final String FETCH_ACCESS_TOKEN_REQUEST_LABEL_REDIRECT_URI = "redirect_uri";
	private static final String FETCH_ACCESS_TOKEN_REQUEST_LABEL_GRANT_TYPE = "grant_type";
	private static final String FETCH_ACCESS_TOKEN_REQUEST_LABEL_REFRESH_TOKEN = "refresh_token";

	private static final String FETCH_ACCESS_TOKEN_REQUEST_VALUE_GRANT_TYPE = "authorization_code";
	private static final String FETCH_ACCESS_TOKEN_REQUEST_VALUE_REDIRECT_URI = "urn:ietf:wg:oauth:2.0:oob";

	private static final String FETCH_ACCESS_TOKEN_REPLY_LABEL_ACCESS_TOKEN = "access_token";
	private static final String FETCH_ACCESS_TOKEN_REPLY_LABEL_REFRESH_TOKEN = "refresh_token";
	private static final String FETCH_ACCESS_TOKEN_REPLY_LABEL_EXPIRES_IN = "expires_in";

	private static final long ACCESS_TOKEN_EXPIRY_BUFFER = 120_000L; // in milliseconds
	private static final long ACCESS_TOKEN_EXPIRY_PERIOD_CONVERSION_FACTOR = 1_000L; // factor to multiply by to convert the period to milliseconds

	private static final Date UNIX_EPOCH = new Date(0L);

	private static final File AUTHENTICATION_SAVE_FILE = new File("ATC_AUTH.txt");

	private static AuthenticationManager instance = null;
	private String authenticationToken;
	private String accessToken;
	private String refreshToken;
	private Date accessTokenExpiry;

	private AuthenticationManager() {
		authenticationToken = NULL_TOKEN;
		accessToken = NULL_TOKEN;
		refreshToken = NULL_TOKEN;
		accessTokenExpiry = null;
	}

	protected static AuthenticationManager getInstance() {
		if (instance == null) {
			instance = new AuthenticationManager();
		}
		return instance;
	}

	protected boolean isAuthenticated() {
		if (authenticationToken.equals(NULL_TOKEN)) {
			return false;
		}
		return true;
	}

	protected void authenticateUser() {
		AuthenticationManager.getInstance().openAuthenticationDialog();
	}

	// The following two methods should only be called by the
	// AuthenticationDialog class
	protected void authenticateUserSuccess(String authenticationToken) {
		this.authenticationToken = authenticationToken;
	}

	// This method is a fail safe. The user will not be registered as
	// authenticated should any exceptions occur.
	protected void authenticateUserFailed() {
		try {
			deleteAuthenticationDetails();
		} catch (IOException e) {
			// Do nothing. (File could not be written)
			e.printStackTrace();
		}
	}

	protected void deleteAuthenticationDetails() throws IOException {
		authenticationToken = NULL_TOKEN;
		accessToken = NULL_TOKEN;
		refreshToken = NULL_TOKEN;
		accessTokenExpiry = null;
		writeAuthenticationDetailsToFile();
	}

	protected HashMap<String, String> getAuthorizationHeader()
			throws IllegalStateException, JsonParseException, IOException {
		HashMap<String, String> header = new HashMap<>();
		header.put(AUTHORIZATION_HEADER_LABEL,
				AUTHORIZATION_HEADER_VALUE_PREFIX + getAccessToken());
		return header;
	}

	//Catches all IOExceptions and fails cleanly.
	//Upon failure, all tokens will be set to null.
	protected void readAuthenticationDetailsFromFile() {
		try {
			BufferedReader reader = new BufferedReader(new FileReader(AUTHENTICATION_SAVE_FILE));
	
			authenticationToken = reader.readLine();
			accessToken = reader.readLine();
			refreshToken = reader.readLine();
	
			boolean accessTokenIsNull = accessToken.equals(NULL_TOKEN);
			if (accessTokenIsNull) {
				accessTokenExpiry = null;
			} else {
				// assume the token has expired
				accessTokenExpiry = UNIX_EPOCH;
			}
	
			reader.close();
		} catch (IOException e) {
			authenticationToken = NULL_TOKEN;
			accessToken = NULL_TOKEN;
			refreshToken = NULL_TOKEN;
			accessTokenExpiry = null;
		}
	}

	private void fetchAccessTokenUsingAuthenticationToken()
			throws IllegalStateException, JsonParseException, IOException {
		assert !authenticationToken.equals(NULL_TOKEN);

		HashMap<String, String> parameters = new HashMap<>();
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_CODE, authenticationToken);
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_CLIENT_ID, GOOGLE_API_CLIENT_ID);
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_CLIENT_SECRET, GOOGLE_API_CLIENT_SECRET);
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_REDIRECT_URI, FETCH_ACCESS_TOKEN_REQUEST_VALUE_REDIRECT_URI);
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_GRANT_TYPE, FETCH_ACCESS_TOKEN_REQUEST_VALUE_GRANT_TYPE);

		JsonObject serverReply = Utilities.parseToJsonObject(
				Utilities.sendUrlencodedFormHttpsRequest(
						GOOGLE_REQUEST_URL_FETCH_ACCESS_TOKEN,
						Utilities.REQUEST_METHOD_POST,
						Utilities.EMPTY_ADDITIONAL_HEADERS,
						parameters
				)
		);

		accessToken = Utilities.getJsonObjectValueOrEmptyString(serverReply, FETCH_ACCESS_TOKEN_REPLY_LABEL_ACCESS_TOKEN);
		refreshToken = Utilities.getJsonObjectValueOrEmptyString(serverReply, FETCH_ACCESS_TOKEN_REPLY_LABEL_REFRESH_TOKEN);

		long timeNow = new Date().getTime();
		long accessTokenValidityPeriod = serverReply.get(FETCH_ACCESS_TOKEN_REPLY_LABEL_EXPIRES_IN).getAsLong() *
				ACCESS_TOKEN_EXPIRY_PERIOD_CONVERSION_FACTOR;
		long expiryTime = timeNow + accessTokenValidityPeriod - ACCESS_TOKEN_EXPIRY_BUFFER;
		accessTokenExpiry = new Date(expiryTime);
	}

	private void fetchAccessTokenUsingRefreshToken()
			throws IllegalStateException, JsonParseException, IOException {
		assert !refreshToken.equals(NULL_TOKEN);

		HashMap<String, String> parameters = new HashMap<>();
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_REFRESH_TOKEN, refreshToken);
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_CLIENT_ID, GOOGLE_API_CLIENT_ID);
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_CLIENT_SECRET, GOOGLE_API_CLIENT_SECRET);
		parameters.put(FETCH_ACCESS_TOKEN_REQUEST_LABEL_GRANT_TYPE, FETCH_ACCESS_TOKEN_REQUEST_LABEL_REFRESH_TOKEN);

		JsonObject serverReply = Utilities.parseToJsonObject(
				Utilities.sendUrlencodedFormHttpsRequest(
						GOOGLE_REQUEST_URL_FETCH_ACCESS_TOKEN,
						Utilities.REQUEST_METHOD_POST,
						Utilities.EMPTY_ADDITIONAL_HEADERS,
						parameters
				)
		);

		accessToken = Utilities.getJsonObjectValueOrEmptyString(serverReply, FETCH_ACCESS_TOKEN_REPLY_LABEL_ACCESS_TOKEN);

		long timeNow = new Date().getTime();
		long accessTokenValidityPeriod = serverReply.get(FETCH_ACCESS_TOKEN_REPLY_LABEL_EXPIRES_IN).getAsLong() *
				ACCESS_TOKEN_EXPIRY_PERIOD_CONVERSION_FACTOR;
		long expiryTime = timeNow + accessTokenValidityPeriod - ACCESS_TOKEN_EXPIRY_BUFFER;
		accessTokenExpiry = new Date(expiryTime);
	}

	private void openAuthenticationDialog() {
		NativeInterface.open();
		new AuthenticationDialog();
	}

	private void writeAuthenticationDetailsToFile() throws IOException {
		BufferedWriter writer = new BufferedWriter(new FileWriter(AUTHENTICATION_SAVE_FILE));

		writer.write(authenticationToken);
		writer.newLine();
		writer.write(accessToken);
		writer.newLine();
		writer.write(refreshToken);
		writer.newLine();

		writer.close();
	}

	private String getAccessToken()
			throws IllegalStateException, JsonParseException, IOException {
		assert isAuthenticated();

		boolean accessTokenIsNull = accessToken.equals(NULL_TOKEN);
		if (accessTokenIsNull) {
			fetchAccessTokenUsingAuthenticationToken();
			writeAuthenticationDetailsToFile();
		} else {
			boolean accessTokenHasExpired = accessTokenExpiry.getTime() < new Date().getTime();
			if (accessTokenHasExpired) {
				fetchAccessTokenUsingRefreshToken();
				writeAuthenticationDetailsToFile();
			}
		}
		return accessToken;
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\AuthenticationManager.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\DeleteSyncNode.java
	 */

package com.licensetokil.atypistcalendar.gcal;

public class DeleteSyncNode extends SyncNode {
	private String remoteTaskID;

	public DeleteSyncNode(String remoteTaskID) {
		super();
		setRemoteTaskID(remoteTaskID);
	}

	public String getRemoteTaskID() {
		return remoteTaskID;
	}

	public void setRemoteTaskID(String remoteTaskID) {
		this.remoteTaskID = remoteTaskID;
	}

	protected int getPriority() {
		return SyncNode.PRIORITY_MEDIUM;
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\DeleteSyncNode.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\DoCompleteSyncNode.java
	 */

package com.licensetokil.atypistcalendar.gcal;

public class DoCompleteSyncNode extends SyncNode {
	public DoCompleteSyncNode() {
		super();
	}

	protected int getPriority() {
		return SyncNode.PRIORITY_LOW;
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\DoCompleteSyncNode.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\GoogleCalendarManager.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Logger;

import com.licensetokil.atypistcalendar.ATypistCalendar;
import com.licensetokil.atypistcalendar.parser.AddGoogleAction;
import com.licensetokil.atypistcalendar.parser.GoogleAction;
import com.licensetokil.atypistcalendar.parser.LoginGoogleAction;
import com.licensetokil.atypistcalendar.parser.LogoutGoogleAction;
import com.licensetokil.atypistcalendar.parser.SyncGoogleAction;
import com.licensetokil.atypistcalendar.tasksmanager.Task;


public class GoogleCalendarManager {
	protected static final boolean SYNCER_STATUS_EXECUTING = true;
	protected static final boolean SYNCER_STATUS_SLEEPING = false;

	private static final String MESSAGE_GOOGLE_LOGOUT_NOT_LOGINED = "You are currently not logged in!";
	private static final String MESSAGE_GOOGLE_LOGOUT_FAILED = "An unexpected error occured. Please try again later.";
	private static final String MESSAGE_GOOGLE_LOGOUT_SUCCESSFULLY_LOGGED_OUT = "You have been logged out.";
	private static final String MESSAGE_GOOGLE_LOGIN_LOGGING_IN = "Logging in...";
	private static final String MESSAGE_GOOGLE_LOGIN_ALREADY_LOGINED = "You are already logged in!";

	private static final String MESSAGE_GOOGLE_SYNC_SYNCHORINZATION_INITIATED = "Synchorinzation with Google Calendar has been initiated. This will take place in the background.";
	private static final String MESSAGE_GOOGLE_SYNC_NOT_LOGINED = "You are currently not logged in! You will need to Login first before you can synchornise your tasks to Google Calendar. Use 'google login' to login.";

	private static final String MESSAGE_GOOGLE_ADD_NOT_LOGINED = "You are currently not logged in! You will need to Login first before you can use Google's Quick Add feature. Use 'google login' to login.";
	private static final String MESSAGE_GOOGLE_ADD_NO_USER_INPUT = "Error - you didn't include any text after the 'google add' command!";

	private static GoogleCalendarManager instance = null;

	private static Logger logger = Logger.getLogger(GoogleCalendarManager.class.getName());

	private GoogleCalendarManager() {
	}

	static public GoogleCalendarManager getInstance() {
		if (instance == null) {
			logger.info("Instance does not exist, creating new instance.");
			instance = new GoogleCalendarManager();
		}
		return instance;
	}

	public void initialize() {
		logger.info("Reading from ATC_AUTH.txt file, if possible.");
		AuthenticationManager.getInstance().readAuthenticationDetailsFromFile();

		logger.info("Checking if user is previously authenticated (from file), else authenticate through OAuth2.");
		if (!AuthenticationManager.getInstance().isAuthenticated()) {
			logger.info("User is not authenticated (from file), authenticating.");
			AuthenticationManager.getInstance().authenticateUser();
		}

		logger.info("Checking if user is authenticated...");
		if (AuthenticationManager.getInstance().isAuthenticated()) {
			logger.info("User is authenticated. Initialising remote calender, and then doing complete sync.");
			initialiseRemoteCalendar();
			doCompleteSync();
		} else {
			logger.info("User is not authenticated. Nothing to do.");
		}
	}

	public String executeCommand(GoogleAction action) {
		logger.info("Determining GoogleAction subtype.");
		if (action instanceof AddGoogleAction) {
			logger.info("AddGoogleAction sub-type detected.");
			return executeGoogleAction((AddGoogleAction) action);
		} else if (action instanceof SyncGoogleAction) {
			logger.info("SyncGoogleAction sub-type detected.");
			return executeGoogleAction((SyncGoogleAction) action);
		} else if (action instanceof LoginGoogleAction) {
			logger.info("LoginGoogleAction sub-type detected.");
			return executeGoogleAction((LoginGoogleAction) action);
		} else if (action instanceof LogoutGoogleAction) {
			logger.info("LogoutGoogleAction sub-type detected.");
			return executeGoogleAction((LogoutGoogleAction) action);
		} else {
			logger.severe("Unknown sub-class of GoogleAction received!");
			assert false;
			return "";
		}
	}

	public void initialiseRemoteCalendar() {
		logger.info("initialiseRemoteCalendar() called.");
		SyncManager.getInstance().initialiseRemoteCalendar();
	}

	public void addRemoteTask(Task localTask) {
		logger.info("addRemoteTask(Task localTask) called - localTask ID: " + localTask.getUniqueId());
		SyncManager.getInstance().addRemoteTask(localTask);
	}

	public void updateRemoteTask(Task localTask, String remoteTask) {
		logger.info("updateRemoteTask(Task localTask, String remoteTask) called. localTask ID: " + localTask.getUniqueId() + " . remoteTask ID: " + remoteTask);
		SyncManager.getInstance().updateRemoteTask(localTask, remoteTask);
	}

	public void deleteRemoteTask(String remoteTask) {
		logger.info("deleteRemoteTask(String remoteTask) called. remoteTask ID: " + remoteTask);
		SyncManager.getInstance().deleteRemoteTask(remoteTask);
	}

	public void doCompleteSync() {
		logger.info("doCompleteSync() called.");
		SyncManager.getInstance().doCompleteSync();
	}

	protected void updateTasksManagerWithUpdatedLocalTask(Task updatedLocalTask) {
		ATypistCalendar.getInstance().updateTasksManagerWithUpdatedLocalTask(updatedLocalTask);
	}

	protected void deleteLocalTaskfromTasksManager(int localTaskId) {
		ATypistCalendar.getInstance().deleteLocalTaskfromTasksManager(localTaskId);
	}

	protected Task insertLocalTaskIntoTasksManager(String description, String location, Calendar lastModifiedDate, String remoteTaskId) {
		return ATypistCalendar.getInstance().insertLocalTaskIntoTasksManager(description, location, lastModifiedDate, remoteTaskId);
	}

	protected Task insertLocalTaskIntoTasksManager(String description, String location, Calendar lastModifiedDate, String remoteTaskId, Calendar endTime) {
		return ATypistCalendar.getInstance().insertLocalTaskIntoTasksManager(description, location, lastModifiedDate, remoteTaskId, endTime);
	}

	protected Task insertLocalTaskIntoTasksManager(String description, String location, Calendar lastModifiedDate, String remoteTaskId, Calendar endTime, Calendar startTime) {
		return ATypistCalendar.getInstance().insertLocalTaskIntoTasksManager(description, location, lastModifiedDate, remoteTaskId, endTime, startTime);
	}

	protected void updateLocalTaskWithCorrespondingTaskRemoteId(int localTaskId, String remoteTaskId) {
		ATypistCalendar.getInstance().updateLocalTaskWithCorrespondingTaskRemoteId(localTaskId, remoteTaskId);
	}

	protected ArrayList<Task> getCopyOfAllLocalTasks() {
		return ATypistCalendar.getInstance().getCopyOfAllLocalTasks();
	}

	protected void setSyncerStatus(boolean isExecuting) {
		ATypistCalendar.getInstance().setSyncerStatus(isExecuting);
	}

	private String executeGoogleAction(AddGoogleAction action) {
		logger.info("Checking if user is logged in.");
		if (AuthenticationManager.getInstance().isAuthenticated()) {

			logger.info("User is logged in. Checking if user input is empty.");
			if (action.getUserInput().isEmpty()) {
				logger.info("User input is empty. Returning with error message.");
				return MESSAGE_GOOGLE_ADD_NO_USER_INPUT;
			} else {
				logger.info("User input is not empty. Calling SyncManager.");
				return SyncManager.getInstance().executeAddGoogleAction(action);
			}

		} else {
			logger.info("User is not logged in. Returning with error message.");
			return MESSAGE_GOOGLE_ADD_NOT_LOGINED;
		}
	}

	private String executeGoogleAction(SyncGoogleAction action) {
		logger.info("Checking if user is logged in.");
		if (AuthenticationManager.getInstance().isAuthenticated()) {
			logger.info("User is logged in. Initiating complete sync.");
			doCompleteSync();
			return MESSAGE_GOOGLE_SYNC_SYNCHORINZATION_INITIATED;
		} else {
			logger.info("User is not logged in. Returning with error message.");
			return MESSAGE_GOOGLE_SYNC_NOT_LOGINED;
		}
	}

	private String executeGoogleAction(LoginGoogleAction action) {
		logger.info("Checking if user is logged in.");
		if (AuthenticationManager.getInstance().isAuthenticated()) {
			logger.info("User is already logged in. Returning with error message.");
			return MESSAGE_GOOGLE_LOGIN_ALREADY_LOGINED;
		} else {
			logger.info("User is not logged in. Calling AuthenticationManager to authenticate user.");
			AuthenticationManager.getInstance().authenticateUser();
			return MESSAGE_GOOGLE_LOGIN_LOGGING_IN;
		}
	}

	private String executeGoogleAction(LogoutGoogleAction action) {
		logger.info("Checking if user is logged in.");
		if (AuthenticationManager.getInstance().isAuthenticated()) {
			logger.info("User is logged in. Calling deleting authentication details (to logout).");

			try {
				AuthenticationManager.getInstance().deleteAuthenticationDetails();
			} catch (IOException e) {
				logger.warning("Problem writing to authentication details to file (IOException's source is writeAuthenticationDetailsToFile()).");
				e.printStackTrace();
				return MESSAGE_GOOGLE_LOGOUT_FAILED;
			}

			return MESSAGE_GOOGLE_LOGOUT_SUCCESSFULLY_LOGGED_OUT;
		} else {
			logger.info("User is not logged in. Returning with error message.");
			return MESSAGE_GOOGLE_LOGOUT_NOT_LOGINED;
		}
	}
}
	// End of segment: src\com\licensetokil\atypistcalendar\gcal\GoogleCalendarManager.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\InitialiseRemoteCalendarSyncNode.java
	 */

package com.licensetokil.atypistcalendar.gcal;

public class InitialiseRemoteCalendarSyncNode extends SyncNode {
	public InitialiseRemoteCalendarSyncNode() {
		super();
	}

	protected int getPriority() {
		return SyncNode.PRIORITY_HIGH;
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\InitialiseRemoteCalendarSyncNode.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\Syncer.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.licensetokil.atypistcalendar.tasksmanager.Deadline;
import com.licensetokil.atypistcalendar.tasksmanager.Schedule;
import com.licensetokil.atypistcalendar.tasksmanager.Task;
import com.licensetokil.atypistcalendar.tasksmanager.Todo;

class Syncer extends Thread {
	private static final String TASK_DESCRIPTION_PREFIX_TODO = "Todo: ";
	private static final String TASK_DESCRIPTION_PREFIX_DEADLINE = "DL: ";

	private static final String CALENDARS_LIST_RESOURCE_LABEL_ITEMS_ARRAY = "items";

	private static final String CALENDAR_RESOURCE_LABEL_SUMMARY = "summary";
	private static final String CALENDAR_RESOURCE_LABEL_TIMEZONE = "timeZone";
	private static final String CALENDAR_RESOURCE_LABEL_LOCATION = "location";
	private static final String CALENDAR_RESOURCE_LABEL_ID = "id";

	private static final String EVENTS_LIST_RESOURCE_PAGE_TOKEN = "pageToken";
	private static final String EVENTS_LIST_RESOURCE_LABEL_ITEMS_ARRAY = "items";

	private static final String EVENT_RESOURCE_LABEL_LOCATION = "location";
	private static final String EVENT_RESOURCE_LABEL_SUMMARY = "summary";
	private static final String EVENT_RESOURCE_LABEL_END = "end";
	private static final String EVENT_RESOURCE_LABEL_START = "start";
	private static final String EVENT_RESOURCE_LABEL_EXTENDED_PROPERTIES = "extendedProperties";
	private static final String EVENT_RESOURCE_LABEL_RECURRENCE = "recurrence";
	private static final String EVENT_RESOURCE_LABEL_ID = "id";
	private static final String EVENT_RESOURCE_LABEL_UPDATED = "updated";

	private static final String EVENT_EXTENDED_PROPERTIES_RESOURCE_LABEL_PRIVATE = "private";

	private static final String EVENT_EXTENDED_PROPERTIES_PRIVATE_RESOURCE_LABEL_ATC_LOCAL_TASK_ID = "atc_localTaskId";

	private static final String GOOGLE_REQUEST_URL_LIST_CALENDARS = "https://www.googleapis.com/calendar/v3/users/me/calendarList";
	private static final String GOOGLE_REQUEST_URL_ADD_CALENDAR = "https://www.googleapis.com/calendar/v3/calendars";
	private static final String GOOGLE_REQUEST_URL_LIST_EVENTS = "https://www.googleapis.com/calendar/v3/calendars/%s/events";
	private static final String GOOGLE_REQUEST_URL_ADD_EVENT = "https://www.googleapis.com/calendar/v3/calendars/%s/events";
	private static final String GOOGLE_REQUEST_URL_UPDATE_EVENT = "https://www.googleapis.com/calendar/v3/calendars/%s/events/%s";
	private static final String GOOGLE_REQUEST_URL_DELETE_EVENT = "https://www.googleapis.com/calendar/v3/calendars/%s/events/%s";

	private static final int PERIOD_TO_SLEEP_IN_SECONDS = 15000;

	private static final String EMPTY_PAGE_TOKEN = "";
	private static final Task NULL_CORRESPONDING_LOCAL_TASK = null;
	private static final int NULL_CORRESPONDING_LOCAL_TASK_ID = -1;

	private static Logger logger = Logger.getLogger(Syncer.class.getName());

	public Syncer() {
		setPriority(Thread.MIN_PRIORITY);
	}

	@Override
	public void run() {
		logger.info("Syncer is running.");

		GoogleCalendarManager.getInstance().setSyncerStatus(GoogleCalendarManager.SYNCER_STATUS_EXECUTING);

		while (true) {
			SyncNode currentSyncNode = SyncManager.getInstance().getSyncQueue().poll();

			while (currentSyncNode != null) {
				try {
					logger.info("Working on next SyncNode. Figuring out the sub-type.");
					determineSyncNodeSubtypeAndExecute(currentSyncNode);

					logger.info("Dequeuing SyncNode item that has been completed (removing head of queue).");
					currentSyncNode = SyncManager.getInstance().getSyncQueue().poll();
				} catch (IllegalStateException | JsonParseException | IOException e) {
					logger.warning("Exception thrown: " + e.getMessage());
					logger.warning("Sleeping before retrying...");

					sleep();

					logger.info("Thread woke up. Retrying...");
				}
			}

			logger.info("Queue is empty, sleeping before next sync...");
			sleep();
			logger.info("Thread woke up. Checking if queue is empty.");
			if (SyncManager.getInstance().getSyncQueue().isEmpty()) {
				logger.info("Queue is empty. Doing a complete sync.");
				SyncManager.getInstance().doCompleteSync();
			} else {
				logger.info("Queue is not empty. Continuing with enqueued SyncNode.");
			}
		}
	}

	private void determineSyncNodeSubtypeAndExecute(SyncNode currentSyncNode)
			throws IllegalStateException, JsonParseException, IOException {
		if (currentSyncNode instanceof InitialiseRemoteCalendarSyncNode) {
			logger.info("InitialiseRemoteCalendarSyncNode sub-type detected.");
			executeSyncNode((InitialiseRemoteCalendarSyncNode) currentSyncNode);
		} else if (currentSyncNode instanceof AddSyncNode) {
			logger.info("AddSyncNode sub-type detected.");
			executeSyncNode((AddSyncNode) currentSyncNode);
		} else if (currentSyncNode instanceof UpdateSyncNode) {
			logger.info("UpdateSyncNode sub-type detected.");
			executeSyncNode((UpdateSyncNode) currentSyncNode);
		} else if (currentSyncNode instanceof DeleteSyncNode) {
			logger.info("DeleteSyncNode sub-type detected.");
			executeSyncNode((DeleteSyncNode) currentSyncNode);
		} else if (currentSyncNode instanceof DoCompleteSyncNode) {
			logger.info("DoCompleteSyncNode sub-type detected.");

			logger.info("Checking if following SyncNodes in queue are DoCompleteSyncNode. Dropping them if they are, for efficency.");
			SyncNode nextSyncNode = SyncManager.getInstance().getSyncQueue().peek();
			while (nextSyncNode instanceof DoCompleteSyncNode) {
				logger.info("Dropping next DoCompleteSyncNode");
				SyncManager.getInstance().getSyncQueue().poll();
				nextSyncNode = SyncManager.getInstance().getSyncQueue().peek();
			}
			logger.info("Check done.");

			executeSyncNode((DoCompleteSyncNode) currentSyncNode);
		} else {
			logger.severe("Unexcepted (subclass of) SyncNode enqueued.");
			assert false;
		}
	}

	private void executeSyncNode(InitialiseRemoteCalendarSyncNode currentSyncNode)
			throws JsonParseException, IllegalStateException, IOException {

		logger.info("Checking if remote calendar exists.");
		if (!remoteCalendarExists()) {
			logger.info("Remote calendar does not exist, creating remote calendar.");
			createRemoteCalendar();
		} else {
			logger.info("Remote calendar exists. Nothing to do.");
		}
	}

	private void executeSyncNode(AddSyncNode addSyncNode)
			throws JsonParseException, IllegalStateException, IOException {
		logger.info("Adding: " + addSyncNode.getLocalTask().toString());

		JsonObject requestBody = createRemoteTaskRequestBody(addSyncNode.getLocalTask());

		JsonObject serverReply = Utilities.parseToJsonObject(
				Utilities.sendJsonHttpsRequest(
						String.format(GOOGLE_REQUEST_URL_ADD_EVENT, SyncManager.getInstance().getRemoteCalendarId()),
						Utilities.REQUEST_METHOD_POST,
						AuthenticationManager.getInstance().getAuthorizationHeader(),
						requestBody
				)
		);

		GoogleCalendarManager.getInstance().updateLocalTaskWithCorrespondingTaskRemoteId(
				addSyncNode.getLocalTask().getUniqueId(),
				Utilities.getJsonObjectValueOrEmptyString(serverReply, EVENT_RESOURCE_LABEL_ID)
		);
	}

	private void executeSyncNode(UpdateSyncNode updateSyncNode)
			throws JsonParseException, IllegalStateException, IOException {
		logger.info("Updating remote copy: " + updateSyncNode.getRemoteTaskID() + " to match " + updateSyncNode.getLocalTask().toString());

		JsonObject requestBody = createRemoteTaskRequestBody(updateSyncNode.getLocalTask());

		Utilities.sendJsonHttpsRequest(
				String.format(
						GOOGLE_REQUEST_URL_UPDATE_EVENT,
						SyncManager.getInstance().getRemoteCalendarId(),
						updateSyncNode.getRemoteTaskID()
				),
				Utilities.REQUEST_METHOD_PUT,
				AuthenticationManager.getInstance().getAuthorizationHeader(),
				requestBody
		);
	}

	private void executeSyncNode(DeleteSyncNode deleteSyncNode)
			throws JsonParseException, IllegalStateException, IOException {
		logger.info("Deleting: " + deleteSyncNode.getRemoteTaskID());

		Utilities.sendJsonHttpsRequest(
				String.format(
						GOOGLE_REQUEST_URL_DELETE_EVENT,
						SyncManager.getInstance().getRemoteCalendarId(),
						deleteSyncNode.getRemoteTaskID()
				),
				Utilities.REQUEST_METHOD_DELETE,
				AuthenticationManager.getInstance().getAuthorizationHeader(),
				Utilities.EMPTY_REQUEST_BODY
		);
	}

	private void executeSyncNode(DoCompleteSyncNode currentSyncNode)
			throws JsonParseException, IllegalStateException, IOException {
		logger.fine("executeSyncNode(DoCompleteSyncNode currentSyncNode) called.");

		logger.info("Getting a copy of all local tasks from TasksManager. Tasks will be deleted from this local copy as its corresponding remote task is found. All remaining local tasks without the corresponding remote task will be uploaded accordingly.");
		syncAllTasks(GoogleCalendarManager.getInstance().getCopyOfAllLocalTasks(), EMPTY_PAGE_TOKEN);
	}

	private boolean remoteCalendarExists()
			throws IOException, JsonParseException, IllegalStateException {

		JsonObject serverReply = Utilities.parseToJsonObject(
				Utilities.sendJsonHttpsRequest(
						GOOGLE_REQUEST_URL_LIST_CALENDARS,
						Utilities.REQUEST_METHOD_GET,
						AuthenticationManager.getInstance().getAuthorizationHeader(),
						Utilities.EMPTY_REQUEST_BODY
				)
		);

		JsonArray calendarList = serverReply.getAsJsonArray(CALENDARS_LIST_RESOURCE_LABEL_ITEMS_ARRAY);
		for(JsonElement i : calendarList) {
			JsonObject currentCalendar = (JsonObject) i;

			boolean currentCalendarNameEqualsATypistsCalendar = Utilities
					.getJsonObjectValueOrEmptyString(currentCalendar, CALENDAR_RESOURCE_LABEL_SUMMARY)
					.equals("A Typist's Calendar");
			if (currentCalendarNameEqualsATypistsCalendar) {
				SyncManager.getInstance().setRemoteCalendarId(
						Utilities.getJsonObjectValueOrEmptyString(currentCalendar, CALENDAR_RESOURCE_LABEL_ID)
				);
				return true;
			}
		}

		return false;
	}

	private void createRemoteCalendar()
			throws IOException, JsonParseException, IllegalStateException {

		// Assumes remoteCalendarExists() == true.
		// We don't assert because it's quite an expensive operation
		// (needs to connect to Google and wait for reply).

		JsonObject requestBody = new JsonObject();
		requestBody.addProperty(CALENDAR_RESOURCE_LABEL_SUMMARY, "A Typist's Calendar");
		requestBody.addProperty(CALENDAR_RESOURCE_LABEL_TIMEZONE, Calendar.getInstance().getTimeZone().getID());
		requestBody.addProperty(CALENDAR_RESOURCE_LABEL_LOCATION, Calendar.getInstance().getTimeZone().getID());

		JsonObject serverReply = Utilities.parseToJsonObject(
				Utilities.sendJsonHttpsRequest(
						GOOGLE_REQUEST_URL_ADD_CALENDAR,
						Utilities.REQUEST_METHOD_POST,
						AuthenticationManager.getInstance().getAuthorizationHeader(),
						requestBody
				)
		);

		SyncManager.getInstance().setRemoteCalendarId(
				Utilities.getJsonObjectValueOrEmptyString(serverReply, CALENDAR_RESOURCE_LABEL_ID)
		);
	}

	private void syncAllTasks(ArrayList<Task> localTasks, String pageToken)
			throws IOException, JsonParseException, IllegalStateException {
		logger.info("Getting remote task list with pageToken: " + pageToken);
		JsonObject serverReply = getRemoteTaskList(pageToken);

		logger.info("Iterating through the remote task list (for current page).");
		JsonArray remoteTasksList = serverReply.getAsJsonArray(EVENTS_LIST_RESOURCE_LABEL_ITEMS_ARRAY);
		for (JsonElement i : remoteTasksList) {
			logger.info("Examining next remote task.");
			examineRemoteTask(localTasks, i.getAsJsonObject());
		}
		logger.info("Completed iterating through remote task list (for current page).");

		boolean nextPageTokenExists = Utilities.getJsonObjectValueOrEmptyString(serverReply, "nextPageToken") != EMPTY_PAGE_TOKEN;
		if (nextPageTokenExists) {

			logger.info("Next page for remote task list is avaliable, continuing on to next page.");
			syncAllTasks(localTasks, Utilities.getJsonObjectValueOrEmptyString(serverReply, "nextPageToken"));

		} else {

			logger.info("Already on last page for remote task list. Enqueuing all remaining local tasks (count = " + localTasks.size() + ") for either uploading to Google Calendar or deletion from local list.");
			for (Task currentLocalTask : localTasks) {

				boolean currentLocalTaskHasNoRemoteId = currentLocalTask.getRemoteId() == null;
				if (currentLocalTaskHasNoRemoteId) {
					logger.info("Adding local task, uniqueId = " + currentLocalTask.getUniqueId());
					SyncManager.getInstance().addRemoteTask(currentLocalTask);
				} else {
					logger.info("Deleting local task, uniqueId = " + currentLocalTask.getUniqueId());
					GoogleCalendarManager.getInstance().deleteLocalTaskfromTasksManager(currentLocalTask.getUniqueId());
				}

			}

		}
	}

	private void examineRemoteTask(ArrayList<Task> localTasks, JsonObject remoteTask) {

		int correspondingLocalTaskId = getCorrespondingLocalTaskId(remoteTask);

		logger.info("Checking if remote task was not created by ATC (i.e. by user, or other programs)");
		if (correspondingLocalTaskId == NULL_CORRESPONDING_LOCAL_TASK_ID) {

			logger.info("Remote task was not created by ATC. Inserting into local TasksManger.");
			SyncManager.getInstance().insertRemoteTaskIntoTasksManager(remoteTask);

		} else {

			logger.info("Remote task was created by ATC. Searching for corresponding local task.");
			Task currentLocalTask = searchForCorrespondingLocalTask(localTasks, correspondingLocalTaskId);
			if (currentLocalTask == NULL_CORRESPONDING_LOCAL_TASK) {

				logger.info("Corresponding local task not found, enqueuing to delete remote copy.");
				SyncManager.getInstance().deleteRemoteTask(
						Utilities.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_ID)
				);

			} else {

				logger.info("Corresponding local task found, checking for discrepancies between local and remote copies.");
				if (isIdentical(remoteTask, currentLocalTask)) {
					logger.info("No discrepancies between local and remote copies found. Nothing to do as remote copy is sync'ed.");
				} else {
					logger.info("Discrepancies between local and remote copies found. Synchornising the two copies.");
					synchorniseLocalAndRemoteTask(remoteTask, currentLocalTask);
				}

				logger.info("Removing corresponding local task from the local tasks list.");
				localTasks.remove(currentLocalTask);

			}

		}
	}

	private Task searchForCorrespondingLocalTask(ArrayList<Task> localTasks, int extendedPropertiesLocalTaskID) {

		for (Task currentLocalTask : localTasks) {
			if (extendedPropertiesLocalTaskID == currentLocalTask.getUniqueId()) {
				return currentLocalTask;
			}
		}
		return NULL_CORRESPONDING_LOCAL_TASK;
	}

	private void synchorniseLocalAndRemoteTask(JsonObject remoteTask, Task currentLocalTask) {
		Calendar remoteTaskLastModifiedTime = null;
		try {
			remoteTaskLastModifiedTime = Utilities.parseGenericGoogleDateString(
					Utilities.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_UPDATED),
					Utilities.RFC3339_FORMAT_WITH_MILLISECONDS
			);
		} catch (ParseException e) {
			logger.severe("Unable to parse Google DateTime object. Unexpected as Google returns a standard format. Failing quietly.");
			e.printStackTrace();
			return;
		}

		Calendar localTaskLastModifiedTime = currentLocalTask.getLastModifiedDate();

		boolean localTaskModifiedLaterThanRemoteTask = localTaskLastModifiedTime.compareTo(remoteTaskLastModifiedTime) >= 0;
		if (localTaskModifiedLaterThanRemoteTask) {

			SyncManager.getInstance().updateRemoteTask(
					currentLocalTask,
					Utilities.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_ID)
			);

		} else {
			updateLocalTaskFromRemoteTask(remoteTask, currentLocalTask);
		}
	}

	private JsonObject getRemoteTaskList(String pageToken)
			throws IOException, JsonParseException, IllegalStateException {

		HashMap<String, String> formParameters = Utilities.EMPTY_FORM_PARAMETERS;

		if (pageToken != EMPTY_PAGE_TOKEN) {
			formParameters = new HashMap<String, String>();
			formParameters.put(EVENTS_LIST_RESOURCE_PAGE_TOKEN, pageToken);
		}

		JsonObject serverReply = Utilities.parseToJsonObject(
				Utilities.sendUrlencodedFormHttpsRequest(
						String.format(
								GOOGLE_REQUEST_URL_LIST_EVENTS,
								SyncManager.getInstance().getRemoteCalendarId()
						),
						Utilities.REQUEST_METHOD_GET,
						AuthenticationManager.getInstance().getAuthorizationHeader(),
						formParameters
				)
		);

		return serverReply;
	}

	private int getCorrespondingLocalTaskId(JsonObject remoteTask) {
		if (privateExtendedPropertiesExist(remoteTask)) {
			return remoteTask
					.getAsJsonObject(EVENT_RESOURCE_LABEL_EXTENDED_PROPERTIES)
					.getAsJsonObject(EVENT_EXTENDED_PROPERTIES_RESOURCE_LABEL_PRIVATE)
					.get(EVENT_EXTENDED_PROPERTIES_PRIVATE_RESOURCE_LABEL_ATC_LOCAL_TASK_ID)
					.getAsInt();
		}
		return NULL_CORRESPONDING_LOCAL_TASK_ID;
	}

	private boolean privateExtendedPropertiesExist(JsonObject remoteTask) {
		if (remoteTask.getAsJsonObject(EVENT_RESOURCE_LABEL_EXTENDED_PROPERTIES) == null) {
			return false;
		}
		if (remoteTask.getAsJsonObject(EVENT_RESOURCE_LABEL_EXTENDED_PROPERTIES)
				.getAsJsonObject(EVENT_EXTENDED_PROPERTIES_RESOURCE_LABEL_PRIVATE) == null) {
			return false;
		}
		if (remoteTask.getAsJsonObject(EVENT_RESOURCE_LABEL_EXTENDED_PROPERTIES)
				.getAsJsonObject(EVENT_EXTENDED_PROPERTIES_RESOURCE_LABEL_PRIVATE)
				.get(EVENT_EXTENDED_PROPERTIES_PRIVATE_RESOURCE_LABEL_ATC_LOCAL_TASK_ID) == null) {
			return false;
		}
		return true;
	}

	private String removePrefix(String originalString, String prefix) {
		String originalStringInLowerCase = originalString.toLowerCase();
		String prefixInLowerCase = prefix.toLowerCase();

		if (originalStringInLowerCase.startsWith(prefixInLowerCase)) {
			return originalString.substring(prefix.length());
		} else {
			return originalString;
		}
	}

	private JsonObject createExtendedPropertiesObject(int localTaskId) {
		JsonObject privateExtendedProperties = new JsonObject();
		privateExtendedProperties.addProperty(
				EVENT_EXTENDED_PROPERTIES_PRIVATE_RESOURCE_LABEL_ATC_LOCAL_TASK_ID,
				Integer.toString(localTaskId)
		);

		JsonObject extendedProperties = new JsonObject();
		extendedProperties.add(
				EVENT_EXTENDED_PROPERTIES_RESOURCE_LABEL_PRIVATE,
				privateExtendedProperties
		);

		return extendedProperties;
	}

	private void sleep() {
		logger.info("Sleeping for " + PERIOD_TO_SLEEP_IN_SECONDS + " seconds.");

		GoogleCalendarManager.getInstance().setSyncerStatus(GoogleCalendarManager.SYNCER_STATUS_SLEEPING);

		try {
			SyncManager.getInstance().getGoToSleepLock().lock();
			SyncManager.getInstance().getGoToSleepCondition()
					.await(PERIOD_TO_SLEEP_IN_SECONDS, TimeUnit.SECONDS);
			SyncManager.getInstance().getGoToSleepLock().unlock();
		} catch (InterruptedException e) {
			logger.severe("Thread was interrupted.");
			e.printStackTrace();
		}

		GoogleCalendarManager.getInstance().setSyncerStatus(GoogleCalendarManager.SYNCER_STATUS_EXECUTING);
	}

	private JsonObject createRemoteTaskRequestBody(Task localTask) {
		if (localTask instanceof Schedule) {
			return createRemoteTaskRequestBodyFromSchedule((Schedule)localTask);
		} else if (localTask instanceof Deadline) {
			return createRemoteTaskRequestBodyFromDeadline((Deadline)localTask);
		} else if (localTask instanceof Todo) {
			return createRemoteTaskRequestBodyFromTodo((Todo)localTask);
		} else {
			logger.severe("Unexpected sub-type of Task detected.");
			assert false;
			return null;
		}
	}

	private JsonObject createRemoteTaskRequestBodyFromSchedule(Schedule localSchedule) {
		JsonObject requestBody = new JsonObject();

		requestBody.addProperty(EVENT_RESOURCE_LABEL_LOCATION, localSchedule.getPlace());
		requestBody.addProperty(EVENT_RESOURCE_LABEL_SUMMARY, localSchedule.getDescription());
		requestBody.add(EVENT_RESOURCE_LABEL_EXTENDED_PROPERTIES, createExtendedPropertiesObject(localSchedule.getUniqueId()));
		requestBody.add(EVENT_RESOURCE_LABEL_START, Utilities.createGoogleDateTimeObject(localSchedule.getStartTime()));
		requestBody.add(EVENT_RESOURCE_LABEL_END, Utilities.createGoogleDateTimeObject(localSchedule.getEndTime()));

		return requestBody;
	}

	private JsonObject createRemoteTaskRequestBodyFromDeadline(Deadline localDeadline) {
		// TODO handle done/undone
		JsonObject requestBody = new JsonObject();

		requestBody.addProperty(EVENT_RESOURCE_LABEL_LOCATION, localDeadline.getPlace());
		requestBody.addProperty(EVENT_RESOURCE_LABEL_SUMMARY, TASK_DESCRIPTION_PREFIX_DEADLINE + localDeadline.getDescription());
		requestBody.add(EVENT_RESOURCE_LABEL_EXTENDED_PROPERTIES, createExtendedPropertiesObject(localDeadline.getUniqueId()));
		requestBody.add(EVENT_RESOURCE_LABEL_START, Utilities.createGoogleDateTimeObject(localDeadline.getEndTime()));
		requestBody.add(EVENT_RESOURCE_LABEL_END, Utilities.createGoogleDateTimeObject(localDeadline.getEndTime()));

		return requestBody;
	}

	private JsonObject createRemoteTaskRequestBodyFromTodo(Todo localTodo) {
		// TODO handle done/undone
		JsonObject requestBody = new JsonObject();

		requestBody.addProperty(EVENT_RESOURCE_LABEL_LOCATION, localTodo.getPlace());
		requestBody.addProperty(EVENT_RESOURCE_LABEL_SUMMARY, TASK_DESCRIPTION_PREFIX_TODO + localTodo.getDescription());
		requestBody.add(EVENT_RESOURCE_LABEL_EXTENDED_PROPERTIES, createExtendedPropertiesObject(localTodo.getUniqueId()));
		requestBody.add(EVENT_RESOURCE_LABEL_START, Utilities.createGoogleDateObject(SyncManager.REMOTE_TODO_START_END_DATE));
		requestBody.add(EVENT_RESOURCE_LABEL_END, Utilities.createGoogleDateObject(SyncManager.REMOTE_TODO_START_END_DATE));
		requestBody.add(EVENT_RESOURCE_LABEL_RECURRENCE, SyncManager.REMOTE_TODO_RECURRENCE_PROPERTY);

		return requestBody;
	}

	private void updateLocalTaskFromRemoteTask(JsonObject remoteTask, Task currentLocalTask) {
		// Extracting the (common) fields from the RemoteTask object.
		String remoteTaskId = Utilities.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_ID);
		String description = Utilities.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_SUMMARY);
		String location = Utilities.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_LOCATION);
		Calendar lastModifiedDate = SyncManager.getLastModifiedDateOrTimeNow(remoteTask);

		if (currentLocalTask instanceof Todo) {

			logger.info("currentLocalTask is of type Todo.");
			updateLocalTodo((Todo) currentLocalTask, description, location, remoteTaskId, lastModifiedDate);

		} else {

			// Extract the start and end time of the RemoteTask object.
			Calendar startTime = null;
			Calendar endTime = null;
			try {
				startTime = Utilities.parseGoogleDateTimeObject(remoteTask.getAsJsonObject(EVENT_RESOURCE_LABEL_START));
				endTime = Utilities.parseGoogleDateTimeObject(remoteTask.getAsJsonObject(EVENT_RESOURCE_LABEL_END));
			} catch (ParseException e) {
				logger.severe("Unable to parse Google DateTime object (this is unexpected as Google only returns a standardised format). Failing quietly.");
				e.printStackTrace();
				assert false;
				return;
			}

			if (currentLocalTask instanceof Deadline) {
				logger.info("currentLocalTask is of type Deadline.");
				updateLocalDeadline((Deadline) currentLocalTask, remoteTaskId, description, location, lastModifiedDate, endTime);
			} else if (currentLocalTask instanceof Schedule) {
				logger.info("currentLocalTask is of type Schedule.");
				updateLocalSchedule((Schedule) currentLocalTask, remoteTaskId, description, location, lastModifiedDate, startTime, endTime);
			} else {
				logger.severe("Unknown Task sub-type detected.");
				assert false;
			}

		}
	}

	private void updateLocalTodo(Todo localTodo, String description,
			String location, String remoteTaskId, Calendar lastModifiedDate) {
		localTodo.setDescription(removePrefix(description, TASK_DESCRIPTION_PREFIX_TODO));
		localTodo.setPlace(location);
		localTodo.setLastModifiedDate(lastModifiedDate);
		localTodo.setRemoteId(remoteTaskId);

		GoogleCalendarManager.getInstance().updateTasksManagerWithUpdatedLocalTask(localTodo);
	}

	private void updateLocalDeadline(Deadline localDeadline,
			String remoteTaskId, String description, String location,
			Calendar lastModifiedDate, Calendar endTime) {
		localDeadline.setDescription(removePrefix(description, TASK_DESCRIPTION_PREFIX_DEADLINE));
		localDeadline.setPlace(location);
		localDeadline.setLastModifiedDate(lastModifiedDate);
		localDeadline.setEndTime(endTime);
		localDeadline.setRemoteId(remoteTaskId);

		GoogleCalendarManager.getInstance().updateTasksManagerWithUpdatedLocalTask(localDeadline);
	}

	private void updateLocalSchedule(Schedule localSchedule,
			String remoteTaskId, String description, String location,
			Calendar lastModifiedDate, Calendar startTime, Calendar endTime) {
		localSchedule.setDescription(description);
		localSchedule.setPlace(location);
		localSchedule.setLastModifiedDate(lastModifiedDate);
		localSchedule.setStartTime(startTime);
		localSchedule.setEndTime(endTime);
		localSchedule.setRemoteId(remoteTaskId);

		GoogleCalendarManager.getInstance().updateTasksManagerWithUpdatedLocalTask(localSchedule);
	}

	private boolean isIdentical(JsonObject remoteTask, Task localTask) {
		if (localTask instanceof Schedule) {
			return isIdenticalSchedule(remoteTask, (Schedule) localTask);
		} else if (localTask instanceof Deadline) {
			return isIdenticalDeadline(remoteTask, (Deadline) localTask);
		} else if (localTask instanceof Todo) {
			return isIdenticalTodo(remoteTask, (Todo) localTask);
		} else {
			logger.severe("Unknown Task sub-type detected.");
			assert false;
			return false;
		}
	}

	private boolean isIdenticalSchedule(JsonObject remoteTask, Schedule localSchedule) {
		boolean locationIsIdentical = Utilities
				.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_LOCATION)
				.equals(localSchedule.getPlace());
		boolean summaryIsIdentical = Utilities
				.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_SUMMARY)
				.equals(localSchedule.getDescription());
		boolean startTimeIsIdentical = remoteTask
				.getAsJsonObject(EVENT_RESOURCE_LABEL_START)
				.equals(Utilities.createGoogleDateTimeObject(localSchedule.getStartTime()));
		boolean endTimeIsIdentical = remoteTask
				.getAsJsonObject(EVENT_RESOURCE_LABEL_END)
				.equals(Utilities.createGoogleDateTimeObject(localSchedule.getEndTime()));

		return locationIsIdentical &&
				summaryIsIdentical &&
				startTimeIsIdentical &&
				endTimeIsIdentical;
	}

	private boolean isIdenticalDeadline(JsonObject remoteTask, Deadline localDeadline) {
		// TODO handle done/undone
		boolean locationIsIdentical = Utilities
				.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_LOCATION)
				.equals(localDeadline.getPlace());
		boolean summaryIsIdentical = Utilities
				.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_SUMMARY)
				.equals(TASK_DESCRIPTION_PREFIX_DEADLINE + localDeadline.getDescription());
		boolean startTimeIsIdentical = remoteTask
				.getAsJsonObject(EVENT_RESOURCE_LABEL_START)
				.equals(Utilities.createGoogleDateTimeObject(localDeadline.getEndTime()));
		boolean endTimeIsIdentical = remoteTask
				.getAsJsonObject(EVENT_RESOURCE_LABEL_END)
				.equals(Utilities.createGoogleDateTimeObject(localDeadline.getEndTime()));

		return locationIsIdentical &&
				summaryIsIdentical &&
				startTimeIsIdentical &&
				endTimeIsIdentical;
	}

	private boolean isIdenticalTodo(JsonObject remoteTask, Todo localTodo) {
		// TODO handle done/undone
		boolean locationIsIdentical = Utilities
				.getJsonObjectValueOrEmptyString(remoteTask, CALENDAR_RESOURCE_LABEL_LOCATION)
				.equals(localTodo.getPlace());
		boolean summaryIsIdentical = Utilities
				.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_SUMMARY)
				.equals(TASK_DESCRIPTION_PREFIX_TODO + localTodo.getDescription());
		boolean startTimeIsIdentical = remoteTask
				.getAsJsonObject(EVENT_RESOURCE_LABEL_START)
				.equals(Utilities.createGoogleDateObject(SyncManager.REMOTE_TODO_START_END_DATE));
		boolean endTimeIsIdentical = remoteTask
				.getAsJsonObject(EVENT_RESOURCE_LABEL_END)
				.equals(Utilities.createGoogleDateObject(SyncManager.REMOTE_TODO_START_END_DATE));

		boolean recurrenceIsIdentical = false;
		if (remoteTask.get(EVENT_RESOURCE_LABEL_RECURRENCE) != null) {
			recurrenceIsIdentical = remoteTask
					.getAsJsonArray(EVENT_RESOURCE_LABEL_RECURRENCE)
					.equals(SyncManager.REMOTE_TODO_RECURRENCE_PROPERTY);
		}

		return locationIsIdentical &&
				summaryIsIdentical &&
				startTimeIsIdentical &&
				endTimeIsIdentical &&
				recurrenceIsIdentical;
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\Syncer.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\SyncManager.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import java.io.IOException;
import java.text.ParseException;
import java.util.Calendar;
import java.util.HashMap;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Logger;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.licensetokil.atypistcalendar.parser.AddGoogleAction;
import com.licensetokil.atypistcalendar.tasksmanager.Task;

class SyncManager {

	protected static final Calendar REMOTE_TODO_START_END_DATE = Calendar.getInstance();
	protected static final JsonArray REMOTE_TODO_RECURRENCE_PROPERTY = new JsonArray();

	private static final String QUICK_ADD_RESOURCE_LABEL_TEXT = "text";
	private static final String QUICK_ADD_RESOURCE_LABEL_CALENDAR_ID = "calendarId";

	private static final String GOOGLE_REQUEST_URL_QUICK_ADD = "https://www.googleapis.com/calendar/v3/calendars/%s/events/quickAdd";

	private static final String ERROR_MESSAGE_QUICK_ADD_UNABLE_TO_CONNECT_TO_GOOGLE = "A Typist's Calendar is unable to connect to Google. Please try again in a little while.";

	private static final String MESSAGE_QUICK_ADD_SUCCESSFUL = "Added: \n%s";

	private static final String EVENT_RESOURCE_LABEL_UPDATED = "updated";

	private static SyncManager instance = null;

	private static Logger logger = Logger.getLogger(SyncManager.class.getName());

	private Lock goToSleepLock = new ReentrantLock();
	private Condition goToSleepCondition = goToSleepLock.newCondition();

	private PriorityBlockingQueue<SyncNode> syncQueue;
	private Syncer syncer;
	private String remoteCalendarId;

	static {
		REMOTE_TODO_START_END_DATE.set(2013, Calendar.JANUARY, 1);
		REMOTE_TODO_RECURRENCE_PROPERTY.add(new JsonPrimitive("RRULE:FREQ=MONTHLY"));
	}

	private SyncManager() {
		syncQueue = new PriorityBlockingQueue<SyncNode>();
		syncer = null;
		remoteCalendarId = null;
	}

	protected static SyncManager getInstance() {
		if(instance == null) {
			instance = new SyncManager();
		}
		return instance;
	}

	protected void initialiseRemoteCalendar() {
		syncQueue.add(new InitialiseRemoteCalendarSyncNode());
		runSyncer();
	}

	protected void addRemoteTask(Task localTask) {
		syncQueue.add(new AddSyncNode(localTask));
		runSyncer();
	}

	protected void updateRemoteTask(Task localTask, String remoteTaskId) {
		deleteRemoteTask(remoteTaskId);
		addRemoteTask(localTask);
		//TODO temporary measure, cause increasing the iCal sequence number is difficult - see Dev's guide
		//queue.add(new UpdateSyncNode(localTask, remoteTaskID));
		runSyncer();
	}

	protected void deleteRemoteTask(String remoteTaskId) {
		syncQueue.add(new DeleteSyncNode(remoteTaskId));
		runSyncer();
	}

	protected void doCompleteSync() {
		syncQueue.add(new DoCompleteSyncNode());
		runSyncer();
	}

	protected PriorityBlockingQueue<SyncNode> getSyncQueue() {
		return syncQueue;
	}

	protected String getRemoteCalendarId() {
		return remoteCalendarId;
	}

	protected void setRemoteCalendarId(String remoteCalendarId) {
		this.remoteCalendarId = remoteCalendarId;
	}

	protected Lock getGoToSleepLock() {
		return goToSleepLock;
	}

	protected Condition getGoToSleepCondition() {
		return goToSleepCondition;
	}

	protected String executeAddGoogleAction(AddGoogleAction action) {
		HashMap<String, String> formParameters = new HashMap<>();

		formParameters.put(QUICK_ADD_RESOURCE_LABEL_CALENDAR_ID, getRemoteCalendarId());
		formParameters.put(QUICK_ADD_RESOURCE_LABEL_TEXT, action.getUserInput());

		JsonObject serverReply;
		try {
			serverReply = Utilities.parseToJsonObject(
					Utilities.sendUrlencodedFormHttpsRequest(
							String.format(GOOGLE_REQUEST_URL_QUICK_ADD, getRemoteCalendarId()),
							Utilities.REQUEST_METHOD_POST,
							AuthenticationManager.getInstance().getAuthorizationHeader(),
							formParameters
					)
			);
		} catch (JsonParseException | IllegalStateException | IOException e) {
			logger.warning("Unable to connection to Google; exception thrown - " + e.getMessage());
			return ERROR_MESSAGE_QUICK_ADD_UNABLE_TO_CONNECT_TO_GOOGLE;
		}

		return String.format(
				MESSAGE_QUICK_ADD_SUCCESSFUL,
				insertRemoteTaskIntoTasksManager(serverReply).outputStringForDisplay()
		);
	}

	protected Task insertRemoteTaskIntoTasksManager(JsonObject remoteTask) {
		//Extracting the (common) fields from the RemoteTask object.
		String remoteTaskId = Utilities.getJsonObjectValueOrEmptyString(remoteTask, "id");
		String description = Utilities.getJsonObjectValueOrEmptyString(remoteTask, "summary");
		String location = Utilities.getJsonObjectValueOrEmptyString(remoteTask, "location");
		Calendar lastModifiedDate = getLastModifiedDateOrTimeNow(remoteTask);

		Task newLocalTask = null;
		if(remoteTask.getAsJsonObject("start").get("date") != null) {
			//Task type is a todo
			newLocalTask = GoogleCalendarManager.getInstance().insertLocalTaskIntoTasksManager(description, location, lastModifiedDate, remoteTaskId);
		}
		else {
			Calendar startTime = null;
			Calendar endTime = null;
			try {
				startTime = Utilities.parseGoogleDateTimeObject(remoteTask.getAsJsonObject("start"));
				endTime = Utilities.parseGoogleDateTimeObject(remoteTask.getAsJsonObject("end"));
			} catch (ParseException e) {
				logger.severe("Unable to parse Google DateTime object (this is unexpected as Google only returns a standardised format)");
				e.printStackTrace();
				return null;
			}

			boolean startTimeIsTheSameAsEndTime = startTime.compareTo(endTime) == 0;
			if(startTimeIsTheSameAsEndTime) {
				//Task type is a deadline
				newLocalTask = GoogleCalendarManager.getInstance().insertLocalTaskIntoTasksManager(description, location, lastModifiedDate, remoteTaskId, endTime);
			}
			else {
				//Task type is a schedule
				newLocalTask = GoogleCalendarManager.getInstance().insertLocalTaskIntoTasksManager(description, location, lastModifiedDate, remoteTaskId, endTime, startTime);
			}
		}

		//We update the remote task so it gets the local task's ID gets recorded remotely.
		SyncManager.getInstance().updateRemoteTask(newLocalTask, remoteTaskId);
		return newLocalTask;
	}

	protected static Calendar getLastModifiedDateOrTimeNow(JsonObject remoteTask) {
		try {
			return Utilities.parseGenericGoogleDateString(
					Utilities.getJsonObjectValueOrEmptyString(remoteTask, EVENT_RESOURCE_LABEL_UPDATED),
					Utilities.RFC3339_FORMAT_WITH_MILLISECONDS
			);
		} catch (ParseException e) {
			return Calendar.getInstance(); // Fail quietly
		}
	}

	private void runSyncer() {
		if(!AuthenticationManager.getInstance().isAuthenticated()) {
			logger.info("User is not logged in. No use running Syncer as it will return will authentication errors. Nothing else to do, returning. (Logging in will tigger this process again.");
			return;
		}

		if(syncer == null || !syncer.isAlive()) {
			syncer = new Syncer();
			syncer.start();
		}
		else {
			//Signaling... if needed.
			goToSleepLock.lock();
			goToSleepCondition.signal();
			goToSleepLock.unlock();
		}
	}

}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\SyncManager.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\SyncNode.java
	 */

package com.licensetokil.atypistcalendar.gcal;

public abstract class SyncNode implements Comparable<SyncNode> {
	public static final int PRIORITY_HIGH = 1;
	public static final int PRIORITY_MEDIUM = 2;
	public static final int PRIORITY_LOW = 3;

	private static int creationIdCounter = 0;

	protected int creationId = 0;

	public SyncNode() {
		creationId = creationIdCounter++;
	}

	@Override
	public int compareTo(SyncNode obj) {
		if(getPriority() == obj.getPriority()) {
			return getCreationId() - obj.getCreationId();
		}
		return getPriority() - obj.getPriority();
	}

	protected abstract int getPriority();

	protected int getCreationId() {
		return creationId;
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\SyncNode.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\UpdateSyncNode.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import com.licensetokil.atypistcalendar.tasksmanager.Task;

public class UpdateSyncNode extends SyncNode {
	private Task localTask;
	private String remoteTaskID;

	public UpdateSyncNode(Task localTask, String remoteTaskID) {
		super();
		setLocalTask(localTask);
		setRemoteTaskID(remoteTaskID);
	}

	public Task getLocalTask() {
		return localTask;
	}

	public void setLocalTask(Task localTask) {
		this.localTask = localTask;
	}

	public String getRemoteTaskID() {
		return remoteTaskID;
	}

	public void setRemoteTaskID(String remoteTaskID) {
		this.remoteTaskID = remoteTaskID;
	}

	protected int getPriority() {
		return SyncNode.PRIORITY_MEDIUM;
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\UpdateSyncNode.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\Utilities.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import java.io.BufferedInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;

import javax.net.ssl.HttpsURLConnection;

import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonParser;

public class Utilities {
	public static final String REQUEST_METHOD_POST = "POST";
	public static final String REQUEST_METHOD_GET = "GET";
	public static final String REQUEST_METHOD_DELETE = "DELETE";
	public static final String REQUEST_METHOD_PUT = "PUT";

	public static final String CONTENT_TYPE_WWW_FORM_URLENCODED = "application/x-www-form-urlencoded";
	public static final String CONTENT_TYPE_JSON = "application/json";

	public static final HashMap<String, String> EMPTY_ADDITIONAL_HEADERS = null;
	public static final HashMap<String, String> EMPTY_FORM_PARAMETERS = null;
	public static final JsonObject EMPTY_REQUEST_BODY = null;

	public static final SimpleDateFormat RFC3339_FORMAT_WITH_MILLISECONDS = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
	public static final SimpleDateFormat RFC3339_FORMAT_WITHOUT_MILLISECONDS = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");
	public static final SimpleDateFormat GOOGLE_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

	private static final JsonParser JSON_PARSER = new JsonParser();

	private static final String EMPTY_STRING = "";

	private static final String HTTP_HEADER_LABEL_CONTENT_TYPE = "Content-Type";

	private static final String LABEL_DATE = "date";
	private static final String LABEL_DATE_TIME = "dateTime";

	private static final String NO_CONTENT = null;

	public static Calendar parseGoogleDateTimeObject(JsonObject dateTimeObject)
			throws ParseException {
		return parseGenericGoogleDateObject(dateTimeObject, RFC3339_FORMAT_WITHOUT_MILLISECONDS, LABEL_DATE_TIME);
	}

	public static Calendar parseGoogleDateObject(JsonObject dateObject)
			throws ParseException {
		return parseGenericGoogleDateObject(dateObject, GOOGLE_DATE_FORMAT, LABEL_DATE);
	}

	public static Calendar parseGenericGoogleDateObject(
			JsonObject dateTimeObject,
			SimpleDateFormat format,
			String propertyName)
			throws ParseException {
		String googleDateString = getJsonObjectValueOrEmptyString(dateTimeObject, propertyName);
		return parseGenericGoogleDateString(googleDateString, format);
	}

	public static Calendar parseGenericGoogleDateString(String dateTimeString, SimpleDateFormat format)
			throws ParseException {

		Date date = format.parse(dateTimeString);

		Calendar calendar = Calendar.getInstance();
		calendar.setTime(date);

		return calendar;
	}

	public static JsonObject createGoogleDateTimeObject(Calendar date) {
		return createGenericGoogleDateObject(date, RFC3339_FORMAT_WITHOUT_MILLISECONDS, LABEL_DATE_TIME);
	}

	public static JsonObject createGoogleDateObject(Calendar date) {
		return createGenericGoogleDateObject(date, GOOGLE_DATE_FORMAT, LABEL_DATE);
	}

	public static JsonObject createGenericGoogleDateObject(
			Calendar date,
			SimpleDateFormat format,
			String propertyName) {
		JsonObject jsonObject = new JsonObject();
		jsonObject.addProperty(propertyName, createGenericGoogleDateString(date, format));

		return jsonObject;
	}

	public static String createGenericGoogleDateString(Calendar date, SimpleDateFormat format) {
		return format.format(date.getTime());
	}

	public static JsonObject parseToJsonObject(String stringToParse)
			throws JsonParseException, IllegalStateException {
		return (JsonObject) JSON_PARSER.parse(stringToParse);
	}

	public static String sendJsonHttpsRequest(
			String url,
			String requestMethod,
			HashMap<String, String> additionalHeaders,
			JsonObject requestBody)
			throws IOException {

		if (requestMethod == REQUEST_METHOD_GET || requestMethod == REQUEST_METHOD_DELETE) {
			assert requestBody == EMPTY_REQUEST_BODY;
		}

		URL urlObject = new URL(url);
		HttpsURLConnection httpsConnection = (HttpsURLConnection) urlObject.openConnection();

		httpsConnection.setRequestMethod(requestMethod);
		httpsConnection.setRequestProperty(HTTP_HEADER_LABEL_CONTENT_TYPE, CONTENT_TYPE_JSON);

		if (additionalHeaders != EMPTY_ADDITIONAL_HEADERS) {
			addHeaders(httpsConnection, additionalHeaders);
		}

		if (requestBody == EMPTY_REQUEST_BODY) {
			return sendAndReceiveRequest(httpsConnection, NO_CONTENT);
		} else {
			return sendAndReceiveRequest(httpsConnection, requestBody.toString());
		}
	}

	public static String sendUrlencodedFormHttpsRequest(
			String url,
			String requestMethod,
			HashMap<String, String> additionalHeaders,
			HashMap<String, String> formParameters)
			throws IOException {

		assert requestMethod == REQUEST_METHOD_GET || requestMethod == REQUEST_METHOD_POST;

		// Handle form parameters first, because if requestMethod == GET then we need to append it to the url.
		String formParametersAsString = EMPTY_STRING;
		if (formParameters != EMPTY_FORM_PARAMETERS) {
			for(String key : formParameters.keySet()) {
				formParametersAsString += key + "=" + formParameters.get(key) + "&";
			}
		}

		URL urlObject;
		if (requestMethod == REQUEST_METHOD_POST) {
			urlObject = new URL(url);
		} else {
			urlObject = new URL(url + "?" + formParametersAsString);
		}

		HttpsURLConnection httpsConnection = (HttpsURLConnection) urlObject.openConnection();

		httpsConnection.setRequestMethod(requestMethod);
		httpsConnection.setRequestProperty(HTTP_HEADER_LABEL_CONTENT_TYPE, CONTENT_TYPE_WWW_FORM_URLENCODED);

		if (additionalHeaders != EMPTY_ADDITIONAL_HEADERS) {
			addHeaders(httpsConnection, additionalHeaders);
		}

		if (requestMethod == REQUEST_METHOD_POST) {
			return sendAndReceiveRequest(httpsConnection, formParametersAsString);
		} else {
			return sendAndReceiveRequest(httpsConnection, NO_CONTENT);
		}
	}

	public static String getJsonObjectValueOrEmptyString(JsonObject jsonObject, String key) {
		if (jsonObject.get(key) != null) {
			return jsonObject.get(key).getAsString();
		} else {
			return EMPTY_STRING;
		}
	}

	private static void addHeaders(HttpsURLConnection httpsConnection, HashMap<String, String> headers) {
		for(String key : headers.keySet()) {
			httpsConnection.setRequestProperty(key, headers.get(key));
		}
	}

	private static String sendAndReceiveRequest(HttpsURLConnection httpsConnection, String content)
			throws IOException {

		if (content != NO_CONTENT) {
			httpsConnection.setDoOutput(true);
			DataOutputStream dataOutputStream = new DataOutputStream(httpsConnection.getOutputStream());
			dataOutputStream.writeBytes(content);
			dataOutputStream.flush();
			dataOutputStream.close();
		}

		BufferedInputStream serverReplyBufferedInputStream = new BufferedInputStream(httpsConnection.getInputStream());
		StringBuilder serverReplyStringBuilder = new StringBuilder();

		int characterFromInputStream = serverReplyBufferedInputStream.read();
		while (characterFromInputStream != -1) {
			serverReplyStringBuilder.append((char) characterFromInputStream);
			characterFromInputStream = serverReplyBufferedInputStream.read();
		}
		serverReplyBufferedInputStream.close();
		return serverReplyStringBuilder.toString();
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\Utilities.java





	/**
	 * origin: src\com\licensetokil\atypistcalendar\gcal\UtilitiesJUnitTest.java
	 */

package com.licensetokil.atypistcalendar.gcal;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.util.HashMap;

import org.junit.Test;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class UtilitiesJUnitTest {

	@Test
	public void	test_json_get_noArguments_noAdditionalHeaders() {
		try {
			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/get",
					Utilities.REQUEST_METHOD_GET,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					Utilities.EMPTY_REQUEST_BODY);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/get", jsonReply.get("url").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_get_noArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/get",
					Utilities.REQUEST_METHOD_GET,
					headers,
					Utilities.EMPTY_REQUEST_BODY);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/get", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_post_noArguments_noAdditionalHeaders() {
		try {
			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/post",
					Utilities.REQUEST_METHOD_POST,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					Utilities.EMPTY_REQUEST_BODY);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/post", jsonReply.get("url").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_post_noArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/post",
					Utilities.REQUEST_METHOD_POST,
					headers,
					Utilities.EMPTY_REQUEST_BODY);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/post", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_post_withArguments_noAdditionalHeaders() {
		try {
			JsonObject leveltwo = new JsonObject();
			leveltwo.addProperty("leveltwo", "volume");

			JsonObject body = new JsonObject();
			body.add("levelone", leveltwo);
			body.addProperty("fire", "water");

			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/post",
					Utilities.REQUEST_METHOD_POST,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					body);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/post", jsonReply.get("url").getAsString());
			if (!jsonReply.getAsJsonObject("json").equals(body)) {
				fail("Body not matched.");
			}
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_post_withArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			JsonObject leveltwo = new JsonObject();
			leveltwo.addProperty("leveltwo", "volume");

			JsonObject body = new JsonObject();
			body.add("levelone", leveltwo);
			body.addProperty("fire", "water");

			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/post",
					Utilities.REQUEST_METHOD_POST,
					headers,
					body);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/post", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());

			if (!jsonReply.getAsJsonObject("json").equals(body)) {
				fail("Body not matched.");
			}
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_delete_noArguments_noAdditionalHeaders() {
		try {
			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/delete",
					Utilities.REQUEST_METHOD_DELETE,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					Utilities.EMPTY_REQUEST_BODY);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/delete", jsonReply.get("url").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_delete_noArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");
			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/delete",
					Utilities.REQUEST_METHOD_DELETE,
					headers,
					Utilities.EMPTY_REQUEST_BODY);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/delete", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_put_noArguments_noAdditionalHeaders() {
		try {
			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/put",
					Utilities.REQUEST_METHOD_PUT,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					Utilities.EMPTY_REQUEST_BODY);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/put", jsonReply.get("url").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_put_noArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/put",
					Utilities.REQUEST_METHOD_PUT,
					headers,
					Utilities.EMPTY_REQUEST_BODY);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/put", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_put_withArguments_noAdditionalHeaders() {
		try {
			JsonObject leveltwo = new JsonObject();
			leveltwo.addProperty("leveltwo", "volume");

			JsonObject body = new JsonObject();
			body.add("levelone", leveltwo);
			body.addProperty("fire", "water");

			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/put",
					Utilities.REQUEST_METHOD_PUT,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					body);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/put", jsonReply.get("url").getAsString());
			if (!jsonReply.getAsJsonObject("json").equals(body)) {
				fail("Body not matched.");
			}
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_json_put_withArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			JsonObject leveltwo = new JsonObject();
			leveltwo.addProperty("leveltwo", "volume");

			JsonObject body = new JsonObject();
			body.add("levelone", leveltwo);
			body.addProperty("fire", "water");

			String reply = Utilities.sendJsonHttpsRequest(
					"https://httpbin.org/put",
					Utilities.REQUEST_METHOD_PUT,
					headers,
					body);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/put", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());

			if (!jsonReply.getAsJsonObject("json").equals(body)) {
				fail("Body not matched.");
			}
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_formUrlencoded_post_noArguments_noAdditionalHeaders() {
		try {
			String reply = Utilities.sendUrlencodedFormHttpsRequest(
					"https://httpbin.org/post",
					Utilities.REQUEST_METHOD_POST,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					Utilities.EMPTY_FORM_PARAMETERS);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/post", jsonReply.get("url").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_formUrlencoded_post_noArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			String reply = Utilities.sendUrlencodedFormHttpsRequest(
					"https://httpbin.org/post",
					Utilities.REQUEST_METHOD_POST,
					headers,
					Utilities.EMPTY_FORM_PARAMETERS);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/post", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_formUrlencoded_post_withArguments_noAdditionalHeaders() {
		try {
			HashMap<String, String> parameters = new HashMap<>();
			parameters.put("argone", "helloworld");
			parameters.put("argtwo", "cs2103t");

			String reply = Utilities.sendUrlencodedFormHttpsRequest(
					"https://httpbin.org/post",
					Utilities.REQUEST_METHOD_POST,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					parameters);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/post", jsonReply.get("url").getAsString());
			assertEquals("helloworld", jsonReply.get("form").getAsJsonObject().get("argone").getAsString());
			assertEquals("cs2103t", jsonReply.get("form").getAsJsonObject().get("argtwo").getAsString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_formUrlencoded_post_withArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			HashMap<String, String> parameters = new HashMap<>();
			parameters.put("argone", "helloworld");
			parameters.put("argtwo", "cs2103t");


			String reply = Utilities.sendUrlencodedFormHttpsRequest(
					"https://httpbin.org/post",
					Utilities.REQUEST_METHOD_POST,
					headers,
					parameters);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/post", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());
			assertEquals("helloworld", jsonReply.get("form").getAsJsonObject().get("argone").getAsString());
			assertEquals("cs2103t", jsonReply.get("form").getAsJsonObject().get("argtwo").getAsString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_formUrlencoded_get_noArguments_noAdditionalHeaders() {
		try {
			String reply = Utilities.sendUrlencodedFormHttpsRequest(
					"https://httpbin.org/get",
					Utilities.REQUEST_METHOD_GET,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					Utilities.EMPTY_FORM_PARAMETERS);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/get", jsonReply.get("url").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_formUrlencoded_get_noArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			String reply = Utilities.sendUrlencodedFormHttpsRequest(
					"https://httpbin.org/get",
					Utilities.REQUEST_METHOD_GET,
					headers,
					Utilities.EMPTY_FORM_PARAMETERS);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/get", jsonReply.get("url").getAsString());
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());
			assertEquals("{}", jsonReply.get("args").toString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_formUrlencoded_get_withArguments_noAdditionalHeaders() {
		try {
			HashMap<String, String> parameters = new HashMap<>();
			parameters.put("argone", "helloworld");
			parameters.put("argtwo", "cs2103t");

			String reply = Utilities.sendUrlencodedFormHttpsRequest(
					"https://httpbin.org/get",
					Utilities.REQUEST_METHOD_GET,
					Utilities.EMPTY_ADDITIONAL_HEADERS,
					parameters);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/get", jsonReply.get("url").getAsString().substring(0, 22));
			assertEquals("helloworld", jsonReply.get("args").getAsJsonObject().get("argone").getAsString());
			assertEquals("cs2103t", jsonReply.get("args").getAsJsonObject().get("argtwo").getAsString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}

	@Test
	public void test_formUrlencoded_get_withArguments_withAdditionalHeaders() {
		try {
			HashMap<String, String> headers = new HashMap<>();
			headers.put("Custom-Header-One", "tree");
			headers.put("Custom-Header-Two", "rubber");

			HashMap<String, String> parameters = new HashMap<>();
			parameters.put("argone", "helloworld");
			parameters.put("argtwo", "cs2103t");


			String reply = Utilities.sendUrlencodedFormHttpsRequest(
					"https://httpbin.org/get",
					Utilities.REQUEST_METHOD_GET,
					headers,
					parameters);

			JsonObject jsonReply = (JsonObject)new JsonParser().parse(reply);

			assertEquals("http://httpbin.org/get", jsonReply.get("url").getAsString().substring(0, 22));
			assertEquals("tree", jsonReply.getAsJsonObject("headers").get("Custom-Header-One").getAsString());
			assertEquals("rubber", jsonReply.getAsJsonObject("headers").get("Custom-Header-Two").getAsString());
			assertEquals("helloworld", jsonReply.get("args").getAsJsonObject().get("argone").getAsString());
			assertEquals("cs2103t", jsonReply.get("args").getAsJsonObject().get("argtwo").getAsString());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
	}
}

	// End of segment: src\com\licensetokil\atypistcalendar\gcal\UtilitiesJUnitTest.java





